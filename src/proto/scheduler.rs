// This file is generated. Do not edit
// @generated

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_imports)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;
use super::mesos::FrameworkID;
use super::mesos::OfferID;
use super::mesos::AgentID;
use super::mesos::TaskID;
use super::mesos::ExecutorID;
use super::mesos::ContainerID;
use super::mesos::TimeInfo;
use super::mesos::DurationInfo;
use super::mesos::Address;
use super::mesos::URL;
use super::mesos::Unavailability;
use super::mesos::MachineID;
use super::mesos::MachineInfo;
use super::mesos::FrameworkInfo;
use super::mesos::HealthCheck;
use super::mesos::CommandInfo;
use super::mesos::ExecutorInfo;
use super::mesos::MasterInfo;
use super::mesos::AgentInfo;
use super::mesos::Value;
use super::mesos::Attribute;
use super::mesos::Resource;
use super::mesos::TrafficControlStatistics;
use super::mesos::ResourceStatistics;
use super::mesos::ResourceUsage;
use super::mesos::PerfStatistics;
use super::mesos::Request;
use super::mesos::Offer;
use super::mesos::Operation;
use super::mesos::InverseOffer;
use super::mesos::TaskInfo;
use super::mesos::TaskStatus;
use super::mesos::Filters;
use super::mesos::Environment;
use super::mesos::Parameter;
use super::mesos::Parameters;
use super::mesos::Credential;
use super::mesos::Credentials;
use super::mesos::RateLimit;
use super::mesos::RateLimits;
use super::mesos::Image;
use super::mesos::Volume;
use super::mesos::ContainerInfo;
use super::mesos::Labels;
use super::mesos::Label;
use super::mesos::Port;
use super::mesos::Ports;
use super::mesos::DiscoveryInfo;
use super::mesos::Status;
use super::mesos::TaskState;

#[derive(Clone,Default)]
pub struct Event {
    // message fields
    field_type: ::std::option::Option<Event_Type>,
    subscribed: ::protobuf::SingularPtrField<Event_Subscribed>,
    offers: ::protobuf::SingularPtrField<Event_Offers>,
    rescind: ::protobuf::SingularPtrField<Event_Rescind>,
    update: ::protobuf::SingularPtrField<Event_Update>,
    message: ::protobuf::SingularPtrField<Event_Message>,
    failure: ::protobuf::SingularPtrField<Event_Failure>,
    error: ::protobuf::SingularPtrField<Event_Error>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Event {
        static mut instance: ::protobuf::lazy::Lazy<Event> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Event,
        };
        unsafe {
            instance.get(|| {
                Event {
                    field_type: ::std::option::Option::None,
                    subscribed: ::protobuf::SingularPtrField::none(),
                    offers: ::protobuf::SingularPtrField::none(),
                    rescind: ::protobuf::SingularPtrField::none(),
                    update: ::protobuf::SingularPtrField::none(),
                    message: ::protobuf::SingularPtrField::none(),
                    failure: ::protobuf::SingularPtrField::none(),
                    error: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.scheduler.Event.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Event_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> Event_Type {
        self.field_type.unwrap_or(Event_Type::SUBSCRIBED)
    }

    // optional .mesos.v1.scheduler.Event.Subscribed subscribed = 2;

    pub fn clear_subscribed(&mut self) {
        self.subscribed.clear();
    }

    pub fn has_subscribed(&self) -> bool {
        self.subscribed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscribed(&mut self, v: Event_Subscribed) {
        self.subscribed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscribed<'a>(&'a mut self) -> &'a mut Event_Subscribed {
        if self.subscribed.is_none() {
            self.subscribed.set_default();
        };
        self.subscribed.as_mut().unwrap()
    }

    // Take field
    pub fn take_subscribed(&mut self) -> Event_Subscribed {
        self.subscribed.take().unwrap_or_else(|| Event_Subscribed::new())
    }

    pub fn get_subscribed<'a>(&'a self) -> &'a Event_Subscribed {
        self.subscribed.as_ref().unwrap_or_else(|| Event_Subscribed::default_instance())
    }

    // optional .mesos.v1.scheduler.Event.Offers offers = 3;

    pub fn clear_offers(&mut self) {
        self.offers.clear();
    }

    pub fn has_offers(&self) -> bool {
        self.offers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offers(&mut self, v: Event_Offers) {
        self.offers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offers<'a>(&'a mut self) -> &'a mut Event_Offers {
        if self.offers.is_none() {
            self.offers.set_default();
        };
        self.offers.as_mut().unwrap()
    }

    // Take field
    pub fn take_offers(&mut self) -> Event_Offers {
        self.offers.take().unwrap_or_else(|| Event_Offers::new())
    }

    pub fn get_offers<'a>(&'a self) -> &'a Event_Offers {
        self.offers.as_ref().unwrap_or_else(|| Event_Offers::default_instance())
    }

    // optional .mesos.v1.scheduler.Event.Rescind rescind = 4;

    pub fn clear_rescind(&mut self) {
        self.rescind.clear();
    }

    pub fn has_rescind(&self) -> bool {
        self.rescind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rescind(&mut self, v: Event_Rescind) {
        self.rescind = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rescind<'a>(&'a mut self) -> &'a mut Event_Rescind {
        if self.rescind.is_none() {
            self.rescind.set_default();
        };
        self.rescind.as_mut().unwrap()
    }

    // Take field
    pub fn take_rescind(&mut self) -> Event_Rescind {
        self.rescind.take().unwrap_or_else(|| Event_Rescind::new())
    }

    pub fn get_rescind<'a>(&'a self) -> &'a Event_Rescind {
        self.rescind.as_ref().unwrap_or_else(|| Event_Rescind::default_instance())
    }

    // optional .mesos.v1.scheduler.Event.Update update = 5;

    pub fn clear_update(&mut self) {
        self.update.clear();
    }

    pub fn has_update(&self) -> bool {
        self.update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: Event_Update) {
        self.update = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update<'a>(&'a mut self) -> &'a mut Event_Update {
        if self.update.is_none() {
            self.update.set_default();
        };
        self.update.as_mut().unwrap()
    }

    // Take field
    pub fn take_update(&mut self) -> Event_Update {
        self.update.take().unwrap_or_else(|| Event_Update::new())
    }

    pub fn get_update<'a>(&'a self) -> &'a Event_Update {
        self.update.as_ref().unwrap_or_else(|| Event_Update::default_instance())
    }

    // optional .mesos.v1.scheduler.Event.Message message = 6;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: Event_Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message<'a>(&'a mut self) -> &'a mut Event_Message {
        if self.message.is_none() {
            self.message.set_default();
        };
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> Event_Message {
        self.message.take().unwrap_or_else(|| Event_Message::new())
    }

    pub fn get_message<'a>(&'a self) -> &'a Event_Message {
        self.message.as_ref().unwrap_or_else(|| Event_Message::default_instance())
    }

    // optional .mesos.v1.scheduler.Event.Failure failure = 7;

    pub fn clear_failure(&mut self) {
        self.failure.clear();
    }

    pub fn has_failure(&self) -> bool {
        self.failure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failure(&mut self, v: Event_Failure) {
        self.failure = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_failure<'a>(&'a mut self) -> &'a mut Event_Failure {
        if self.failure.is_none() {
            self.failure.set_default();
        };
        self.failure.as_mut().unwrap()
    }

    // Take field
    pub fn take_failure(&mut self) -> Event_Failure {
        self.failure.take().unwrap_or_else(|| Event_Failure::new())
    }

    pub fn get_failure<'a>(&'a self) -> &'a Event_Failure {
        self.failure.as_ref().unwrap_or_else(|| Event_Failure::default_instance())
    }

    // optional .mesos.v1.scheduler.Event.Error error = 8;

    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: Event_Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error<'a>(&'a mut self) -> &'a mut Event_Error {
        if self.error.is_none() {
            self.error.set_default();
        };
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> Event_Error {
        self.error.take().unwrap_or_else(|| Event_Error::new())
    }

    pub fn get_error<'a>(&'a self) -> &'a Event_Error {
        self.error.as_ref().unwrap_or_else(|| Event_Error::default_instance())
    }
}

impl ::protobuf::Message for Event {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.subscribed.set_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.offers.set_default();
                    try!(is.merge_message(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.rescind.set_default();
                    try!(is.merge_message(tmp))
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.update.set_default();
                    try!(is.merge_message(tmp))
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.message.set_default();
                    try!(is.merge_message(tmp))
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.failure.set_default();
                    try!(is.merge_message(tmp))
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.error.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.subscribed.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.offers.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.rescind.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.update.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.message.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.failure.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.error.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            try!(os.write_enum(1, v as i32));
        };
        if let Some(v) = self.subscribed.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.offers.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.rescind.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.update.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.message.as_ref() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.failure.as_ref() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.error.as_ref() {
            try!(os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Event>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Event {
    fn new() -> Event {
        Event::new()
    }

    fn descriptor_static(_: ::std::option::Option<Event>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "field_type",
                    Event::has_field_type,
                    Event::get_field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "subscribed",
                    Event::has_subscribed,
                    Event::get_subscribed,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "offers",
                    Event::has_offers,
                    Event::get_offers,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "rescind",
                    Event::has_rescind,
                    Event::get_rescind,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "update",
                    Event::has_update,
                    Event::get_update,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "message",
                    Event::has_message,
                    Event::get_message,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "failure",
                    Event::has_failure,
                    Event::get_failure,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "error",
                    Event::has_error,
                    Event::get_error,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Event>(
                    "Event",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Event {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_subscribed();
        self.clear_offers();
        self.clear_rescind();
        self.clear_update();
        self.clear_message();
        self.clear_failure();
        self.clear_error();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Event {
    fn eq(&self, other: &Event) -> bool {
        self.field_type == other.field_type &&
        self.subscribed == other.subscribed &&
        self.offers == other.offers &&
        self.rescind == other.rescind &&
        self.update == other.update &&
        self.message == other.message &&
        self.failure == other.failure &&
        self.error == other.error &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Event_Subscribed {
    // message fields
    framework_id: ::protobuf::SingularPtrField<FrameworkID>,
    heartbeat_interval_seconds: ::std::option::Option<f64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Event_Subscribed {
    pub fn new() -> Event_Subscribed {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Event_Subscribed {
        static mut instance: ::protobuf::lazy::Lazy<Event_Subscribed> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Event_Subscribed,
        };
        unsafe {
            instance.get(|| {
                Event_Subscribed {
                    framework_id: ::protobuf::SingularPtrField::none(),
                    heartbeat_interval_seconds: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.FrameworkID framework_id = 1;

    pub fn clear_framework_id(&mut self) {
        self.framework_id.clear();
    }

    pub fn has_framework_id(&self) -> bool {
        self.framework_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framework_id(&mut self, v: FrameworkID) {
        self.framework_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_framework_id<'a>(&'a mut self) -> &'a mut FrameworkID {
        if self.framework_id.is_none() {
            self.framework_id.set_default();
        };
        self.framework_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_framework_id(&mut self) -> FrameworkID {
        self.framework_id.take().unwrap_or_else(|| FrameworkID::new())
    }

    pub fn get_framework_id<'a>(&'a self) -> &'a FrameworkID {
        self.framework_id.as_ref().unwrap_or_else(|| FrameworkID::default_instance())
    }

    // optional double heartbeat_interval_seconds = 2;

    pub fn clear_heartbeat_interval_seconds(&mut self) {
        self.heartbeat_interval_seconds = ::std::option::Option::None;
    }

    pub fn has_heartbeat_interval_seconds(&self) -> bool {
        self.heartbeat_interval_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heartbeat_interval_seconds(&mut self, v: f64) {
        self.heartbeat_interval_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_heartbeat_interval_seconds<'a>(&self) -> f64 {
        self.heartbeat_interval_seconds.unwrap_or(0.)
    }
}

impl ::protobuf::Message for Event_Subscribed {
    fn is_initialized(&self) -> bool {
        if self.framework_id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.framework_id.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_double());
                    self.heartbeat_interval_seconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.framework_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.heartbeat_interval_seconds.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.framework_id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.heartbeat_interval_seconds {
            try!(os.write_double(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Event_Subscribed>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Event_Subscribed {
    fn new() -> Event_Subscribed {
        Event_Subscribed::new()
    }

    fn descriptor_static(_: ::std::option::Option<Event_Subscribed>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "framework_id",
                    Event_Subscribed::has_framework_id,
                    Event_Subscribed::get_framework_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "heartbeat_interval_seconds",
                    Event_Subscribed::has_heartbeat_interval_seconds,
                    Event_Subscribed::get_heartbeat_interval_seconds,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Event_Subscribed>(
                    "Event_Subscribed",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Event_Subscribed {
    fn clear(&mut self) {
        self.clear_framework_id();
        self.clear_heartbeat_interval_seconds();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Event_Subscribed {
    fn eq(&self, other: &Event_Subscribed) -> bool {
        self.framework_id == other.framework_id &&
        self.heartbeat_interval_seconds == other.heartbeat_interval_seconds &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Event_Subscribed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Event_Offers {
    // message fields
    offers: ::protobuf::RepeatedField<Offer>,
    inverse_offers: ::protobuf::RepeatedField<InverseOffer>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Event_Offers {
    pub fn new() -> Event_Offers {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Event_Offers {
        static mut instance: ::protobuf::lazy::Lazy<Event_Offers> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Event_Offers,
        };
        unsafe {
            instance.get(|| {
                Event_Offers {
                    offers: ::protobuf::RepeatedField::new(),
                    inverse_offers: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.Offer offers = 1;

    pub fn clear_offers(&mut self) {
        self.offers.clear();
    }

    // Param is passed by value, moved
    pub fn set_offers(&mut self, v: ::protobuf::RepeatedField<Offer>) {
        self.offers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_offers<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Offer> {
        &mut self.offers
    }

    // Take field
    pub fn take_offers(&mut self) -> ::protobuf::RepeatedField<Offer> {
        ::std::mem::replace(&mut self.offers, ::protobuf::RepeatedField::new())
    }

    pub fn get_offers<'a>(&'a self) -> &'a [Offer] {
        &self.offers
    }

    // repeated .mesos.v1.InverseOffer inverse_offers = 2;

    pub fn clear_inverse_offers(&mut self) {
        self.inverse_offers.clear();
    }

    // Param is passed by value, moved
    pub fn set_inverse_offers(&mut self, v: ::protobuf::RepeatedField<InverseOffer>) {
        self.inverse_offers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inverse_offers<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<InverseOffer> {
        &mut self.inverse_offers
    }

    // Take field
    pub fn take_inverse_offers(&mut self) -> ::protobuf::RepeatedField<InverseOffer> {
        ::std::mem::replace(&mut self.inverse_offers, ::protobuf::RepeatedField::new())
    }

    pub fn get_inverse_offers<'a>(&'a self) -> &'a [InverseOffer] {
        &self.inverse_offers
    }
}

impl ::protobuf::Message for Event_Offers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.offers));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inverse_offers));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.offers.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.inverse_offers.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.offers.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.inverse_offers.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Event_Offers>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Event_Offers {
    fn new() -> Event_Offers {
        Event_Offers::new()
    }

    fn descriptor_static(_: ::std::option::Option<Event_Offers>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "offers",
                    Event_Offers::get_offers,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "inverse_offers",
                    Event_Offers::get_inverse_offers,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Event_Offers>(
                    "Event_Offers",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Event_Offers {
    fn clear(&mut self) {
        self.clear_offers();
        self.clear_inverse_offers();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Event_Offers {
    fn eq(&self, other: &Event_Offers) -> bool {
        self.offers == other.offers &&
        self.inverse_offers == other.inverse_offers &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Event_Offers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Event_Rescind {
    // message fields
    offer_id: ::protobuf::SingularPtrField<OfferID>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Event_Rescind {
    pub fn new() -> Event_Rescind {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Event_Rescind {
        static mut instance: ::protobuf::lazy::Lazy<Event_Rescind> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Event_Rescind,
        };
        unsafe {
            instance.get(|| {
                Event_Rescind {
                    offer_id: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.OfferID offer_id = 1;

    pub fn clear_offer_id(&mut self) {
        self.offer_id.clear();
    }

    pub fn has_offer_id(&self) -> bool {
        self.offer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offer_id(&mut self, v: OfferID) {
        self.offer_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offer_id<'a>(&'a mut self) -> &'a mut OfferID {
        if self.offer_id.is_none() {
            self.offer_id.set_default();
        };
        self.offer_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_offer_id(&mut self) -> OfferID {
        self.offer_id.take().unwrap_or_else(|| OfferID::new())
    }

    pub fn get_offer_id<'a>(&'a self) -> &'a OfferID {
        self.offer_id.as_ref().unwrap_or_else(|| OfferID::default_instance())
    }
}

impl ::protobuf::Message for Event_Rescind {
    fn is_initialized(&self) -> bool {
        if self.offer_id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.offer_id.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.offer_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.offer_id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Event_Rescind>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Event_Rescind {
    fn new() -> Event_Rescind {
        Event_Rescind::new()
    }

    fn descriptor_static(_: ::std::option::Option<Event_Rescind>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "offer_id",
                    Event_Rescind::has_offer_id,
                    Event_Rescind::get_offer_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Event_Rescind>(
                    "Event_Rescind",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Event_Rescind {
    fn clear(&mut self) {
        self.clear_offer_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Event_Rescind {
    fn eq(&self, other: &Event_Rescind) -> bool {
        self.offer_id == other.offer_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Event_Rescind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Event_Update {
    // message fields
    status: ::protobuf::SingularPtrField<TaskStatus>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Event_Update {
    pub fn new() -> Event_Update {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Event_Update {
        static mut instance: ::protobuf::lazy::Lazy<Event_Update> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Event_Update,
        };
        unsafe {
            instance.get(|| {
                Event_Update {
                    status: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.TaskStatus status = 1;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: TaskStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status<'a>(&'a mut self) -> &'a mut TaskStatus {
        if self.status.is_none() {
            self.status.set_default();
        };
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> TaskStatus {
        self.status.take().unwrap_or_else(|| TaskStatus::new())
    }

    pub fn get_status<'a>(&'a self) -> &'a TaskStatus {
        self.status.as_ref().unwrap_or_else(|| TaskStatus::default_instance())
    }
}

impl ::protobuf::Message for Event_Update {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.status.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.status.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Event_Update>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Event_Update {
    fn new() -> Event_Update {
        Event_Update::new()
    }

    fn descriptor_static(_: ::std::option::Option<Event_Update>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "status",
                    Event_Update::has_status,
                    Event_Update::get_status,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Event_Update>(
                    "Event_Update",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Event_Update {
    fn clear(&mut self) {
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Event_Update {
    fn eq(&self, other: &Event_Update) -> bool {
        self.status == other.status &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Event_Update {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Event_Message {
    // message fields
    agent_id: ::protobuf::SingularPtrField<AgentID>,
    executor_id: ::protobuf::SingularPtrField<ExecutorID>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Event_Message {
    pub fn new() -> Event_Message {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Event_Message {
        static mut instance: ::protobuf::lazy::Lazy<Event_Message> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Event_Message,
        };
        unsafe {
            instance.get(|| {
                Event_Message {
                    agent_id: ::protobuf::SingularPtrField::none(),
                    executor_id: ::protobuf::SingularPtrField::none(),
                    data: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.AgentID agent_id = 1;

    pub fn clear_agent_id(&mut self) {
        self.agent_id.clear();
    }

    pub fn has_agent_id(&self) -> bool {
        self.agent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_id(&mut self, v: AgentID) {
        self.agent_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_id<'a>(&'a mut self) -> &'a mut AgentID {
        if self.agent_id.is_none() {
            self.agent_id.set_default();
        };
        self.agent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_id(&mut self) -> AgentID {
        self.agent_id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_agent_id<'a>(&'a self) -> &'a AgentID {
        self.agent_id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }

    // required .mesos.v1.ExecutorID executor_id = 2;

    pub fn clear_executor_id(&mut self) {
        self.executor_id.clear();
    }

    pub fn has_executor_id(&self) -> bool {
        self.executor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executor_id(&mut self, v: ExecutorID) {
        self.executor_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executor_id<'a>(&'a mut self) -> &'a mut ExecutorID {
        if self.executor_id.is_none() {
            self.executor_id.set_default();
        };
        self.executor_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_executor_id(&mut self) -> ExecutorID {
        self.executor_id.take().unwrap_or_else(|| ExecutorID::new())
    }

    pub fn get_executor_id<'a>(&'a self) -> &'a ExecutorID {
        self.executor_id.as_ref().unwrap_or_else(|| ExecutorID::default_instance())
    }

    // required bytes data = 3;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        };
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data<'a>(&'a self) -> &'a [u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for Event_Message {
    fn is_initialized(&self) -> bool {
        if self.agent_id.is_none() {
            return false;
        };
        if self.executor_id.is_none() {
            return false;
        };
        if self.data.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.agent_id.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.executor_id.set_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.data.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.agent_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.executor_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.data.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.agent_id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.executor_id.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.data.as_ref() {
            try!(os.write_bytes(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Event_Message>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Event_Message {
    fn new() -> Event_Message {
        Event_Message::new()
    }

    fn descriptor_static(_: ::std::option::Option<Event_Message>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "agent_id",
                    Event_Message::has_agent_id,
                    Event_Message::get_agent_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "executor_id",
                    Event_Message::has_executor_id,
                    Event_Message::get_executor_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "data",
                    Event_Message::has_data,
                    Event_Message::get_data,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Event_Message>(
                    "Event_Message",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Event_Message {
    fn clear(&mut self) {
        self.clear_agent_id();
        self.clear_executor_id();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Event_Message {
    fn eq(&self, other: &Event_Message) -> bool {
        self.agent_id == other.agent_id &&
        self.executor_id == other.executor_id &&
        self.data == other.data &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Event_Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Event_Failure {
    // message fields
    agent_id: ::protobuf::SingularPtrField<AgentID>,
    executor_id: ::protobuf::SingularPtrField<ExecutorID>,
    status: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Event_Failure {
    pub fn new() -> Event_Failure {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Event_Failure {
        static mut instance: ::protobuf::lazy::Lazy<Event_Failure> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Event_Failure,
        };
        unsafe {
            instance.get(|| {
                Event_Failure {
                    agent_id: ::protobuf::SingularPtrField::none(),
                    executor_id: ::protobuf::SingularPtrField::none(),
                    status: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .mesos.v1.AgentID agent_id = 1;

    pub fn clear_agent_id(&mut self) {
        self.agent_id.clear();
    }

    pub fn has_agent_id(&self) -> bool {
        self.agent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_id(&mut self, v: AgentID) {
        self.agent_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_id<'a>(&'a mut self) -> &'a mut AgentID {
        if self.agent_id.is_none() {
            self.agent_id.set_default();
        };
        self.agent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_id(&mut self) -> AgentID {
        self.agent_id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_agent_id<'a>(&'a self) -> &'a AgentID {
        self.agent_id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }

    // optional .mesos.v1.ExecutorID executor_id = 2;

    pub fn clear_executor_id(&mut self) {
        self.executor_id.clear();
    }

    pub fn has_executor_id(&self) -> bool {
        self.executor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executor_id(&mut self, v: ExecutorID) {
        self.executor_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executor_id<'a>(&'a mut self) -> &'a mut ExecutorID {
        if self.executor_id.is_none() {
            self.executor_id.set_default();
        };
        self.executor_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_executor_id(&mut self) -> ExecutorID {
        self.executor_id.take().unwrap_or_else(|| ExecutorID::new())
    }

    pub fn get_executor_id<'a>(&'a self) -> &'a ExecutorID {
        self.executor_id.as_ref().unwrap_or_else(|| ExecutorID::default_instance())
    }

    // optional int32 status = 3;

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    pub fn get_status<'a>(&self) -> i32 {
        self.status.unwrap_or(0)
    }
}

impl ::protobuf::Message for Event_Failure {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.agent_id.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.executor_id.set_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int32());
                    self.status = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.agent_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.executor_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.status.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.agent_id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.executor_id.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.status {
            try!(os.write_int32(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Event_Failure>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Event_Failure {
    fn new() -> Event_Failure {
        Event_Failure::new()
    }

    fn descriptor_static(_: ::std::option::Option<Event_Failure>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "agent_id",
                    Event_Failure::has_agent_id,
                    Event_Failure::get_agent_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "executor_id",
                    Event_Failure::has_executor_id,
                    Event_Failure::get_executor_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "status",
                    Event_Failure::has_status,
                    Event_Failure::get_status,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Event_Failure>(
                    "Event_Failure",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Event_Failure {
    fn clear(&mut self) {
        self.clear_agent_id();
        self.clear_executor_id();
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Event_Failure {
    fn eq(&self, other: &Event_Failure) -> bool {
        self.agent_id == other.agent_id &&
        self.executor_id == other.executor_id &&
        self.status == other.status &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Event_Failure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Event_Error {
    // message fields
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Event_Error {
    pub fn new() -> Event_Error {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Event_Error {
        static mut instance: ::protobuf::lazy::Lazy<Event_Error> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Event_Error,
        };
        unsafe {
            instance.get(|| {
                Event_Error {
                    message: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string message = 1;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        };
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message<'a>(&'a self) -> &'a str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Event_Error {
    fn is_initialized(&self) -> bool {
        if self.message.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.message.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.message.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.message.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Event_Error>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Event_Error {
    fn new() -> Event_Error {
        Event_Error::new()
    }

    fn descriptor_static(_: ::std::option::Option<Event_Error>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "message",
                    Event_Error::has_message,
                    Event_Error::get_message,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Event_Error>(
                    "Event_Error",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Event_Error {
    fn clear(&mut self) {
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Event_Error {
    fn eq(&self, other: &Event_Error) -> bool {
        self.message == other.message &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Event_Error {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Event_Type {
    SUBSCRIBED = 1,
    OFFERS = 2,
    RESCIND = 3,
    UPDATE = 4,
    MESSAGE = 5,
    FAILURE = 6,
    ERROR = 7,
    HEARTBEAT = 8,
}

impl ::protobuf::ProtobufEnum for Event_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Event_Type> {
        match value {
            1 => ::std::option::Option::Some(Event_Type::SUBSCRIBED),
            2 => ::std::option::Option::Some(Event_Type::OFFERS),
            3 => ::std::option::Option::Some(Event_Type::RESCIND),
            4 => ::std::option::Option::Some(Event_Type::UPDATE),
            5 => ::std::option::Option::Some(Event_Type::MESSAGE),
            6 => ::std::option::Option::Some(Event_Type::FAILURE),
            7 => ::std::option::Option::Some(Event_Type::ERROR),
            8 => ::std::option::Option::Some(Event_Type::HEARTBEAT),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<Event_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Event_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Event_Type {
}

#[derive(Clone,Default)]
pub struct Call {
    // message fields
    framework_id: ::protobuf::SingularPtrField<FrameworkID>,
    field_type: ::std::option::Option<Call_Type>,
    subscribe: ::protobuf::SingularPtrField<Call_Subscribe>,
    accept: ::protobuf::SingularPtrField<Call_Accept>,
    decline: ::protobuf::SingularPtrField<Call_Decline>,
    kill: ::protobuf::SingularPtrField<Call_Kill>,
    shutdown: ::protobuf::SingularPtrField<Call_Shutdown>,
    acknowledge: ::protobuf::SingularPtrField<Call_Acknowledge>,
    reconcile: ::protobuf::SingularPtrField<Call_Reconcile>,
    message: ::protobuf::SingularPtrField<Call_Message>,
    request: ::protobuf::SingularPtrField<Call_Request>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Call {
    pub fn new() -> Call {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Call {
        static mut instance: ::protobuf::lazy::Lazy<Call> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Call,
        };
        unsafe {
            instance.get(|| {
                Call {
                    framework_id: ::protobuf::SingularPtrField::none(),
                    field_type: ::std::option::Option::None,
                    subscribe: ::protobuf::SingularPtrField::none(),
                    accept: ::protobuf::SingularPtrField::none(),
                    decline: ::protobuf::SingularPtrField::none(),
                    kill: ::protobuf::SingularPtrField::none(),
                    shutdown: ::protobuf::SingularPtrField::none(),
                    acknowledge: ::protobuf::SingularPtrField::none(),
                    reconcile: ::protobuf::SingularPtrField::none(),
                    message: ::protobuf::SingularPtrField::none(),
                    request: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .mesos.v1.FrameworkID framework_id = 1;

    pub fn clear_framework_id(&mut self) {
        self.framework_id.clear();
    }

    pub fn has_framework_id(&self) -> bool {
        self.framework_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framework_id(&mut self, v: FrameworkID) {
        self.framework_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_framework_id<'a>(&'a mut self) -> &'a mut FrameworkID {
        if self.framework_id.is_none() {
            self.framework_id.set_default();
        };
        self.framework_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_framework_id(&mut self) -> FrameworkID {
        self.framework_id.take().unwrap_or_else(|| FrameworkID::new())
    }

    pub fn get_framework_id<'a>(&'a self) -> &'a FrameworkID {
        self.framework_id.as_ref().unwrap_or_else(|| FrameworkID::default_instance())
    }

    // required .mesos.v1.scheduler.Call.Type type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Call_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> Call_Type {
        self.field_type.unwrap_or(Call_Type::SUBSCRIBE)
    }

    // optional .mesos.v1.scheduler.Call.Subscribe subscribe = 3;

    pub fn clear_subscribe(&mut self) {
        self.subscribe.clear();
    }

    pub fn has_subscribe(&self) -> bool {
        self.subscribe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscribe(&mut self, v: Call_Subscribe) {
        self.subscribe = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscribe<'a>(&'a mut self) -> &'a mut Call_Subscribe {
        if self.subscribe.is_none() {
            self.subscribe.set_default();
        };
        self.subscribe.as_mut().unwrap()
    }

    // Take field
    pub fn take_subscribe(&mut self) -> Call_Subscribe {
        self.subscribe.take().unwrap_or_else(|| Call_Subscribe::new())
    }

    pub fn get_subscribe<'a>(&'a self) -> &'a Call_Subscribe {
        self.subscribe.as_ref().unwrap_or_else(|| Call_Subscribe::default_instance())
    }

    // optional .mesos.v1.scheduler.Call.Accept accept = 4;

    pub fn clear_accept(&mut self) {
        self.accept.clear();
    }

    pub fn has_accept(&self) -> bool {
        self.accept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accept(&mut self, v: Call_Accept) {
        self.accept = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accept<'a>(&'a mut self) -> &'a mut Call_Accept {
        if self.accept.is_none() {
            self.accept.set_default();
        };
        self.accept.as_mut().unwrap()
    }

    // Take field
    pub fn take_accept(&mut self) -> Call_Accept {
        self.accept.take().unwrap_or_else(|| Call_Accept::new())
    }

    pub fn get_accept<'a>(&'a self) -> &'a Call_Accept {
        self.accept.as_ref().unwrap_or_else(|| Call_Accept::default_instance())
    }

    // optional .mesos.v1.scheduler.Call.Decline decline = 5;

    pub fn clear_decline(&mut self) {
        self.decline.clear();
    }

    pub fn has_decline(&self) -> bool {
        self.decline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decline(&mut self, v: Call_Decline) {
        self.decline = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_decline<'a>(&'a mut self) -> &'a mut Call_Decline {
        if self.decline.is_none() {
            self.decline.set_default();
        };
        self.decline.as_mut().unwrap()
    }

    // Take field
    pub fn take_decline(&mut self) -> Call_Decline {
        self.decline.take().unwrap_or_else(|| Call_Decline::new())
    }

    pub fn get_decline<'a>(&'a self) -> &'a Call_Decline {
        self.decline.as_ref().unwrap_or_else(|| Call_Decline::default_instance())
    }

    // optional .mesos.v1.scheduler.Call.Kill kill = 6;

    pub fn clear_kill(&mut self) {
        self.kill.clear();
    }

    pub fn has_kill(&self) -> bool {
        self.kill.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kill(&mut self, v: Call_Kill) {
        self.kill = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kill<'a>(&'a mut self) -> &'a mut Call_Kill {
        if self.kill.is_none() {
            self.kill.set_default();
        };
        self.kill.as_mut().unwrap()
    }

    // Take field
    pub fn take_kill(&mut self) -> Call_Kill {
        self.kill.take().unwrap_or_else(|| Call_Kill::new())
    }

    pub fn get_kill<'a>(&'a self) -> &'a Call_Kill {
        self.kill.as_ref().unwrap_or_else(|| Call_Kill::default_instance())
    }

    // optional .mesos.v1.scheduler.Call.Shutdown shutdown = 7;

    pub fn clear_shutdown(&mut self) {
        self.shutdown.clear();
    }

    pub fn has_shutdown(&self) -> bool {
        self.shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shutdown(&mut self, v: Call_Shutdown) {
        self.shutdown = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shutdown<'a>(&'a mut self) -> &'a mut Call_Shutdown {
        if self.shutdown.is_none() {
            self.shutdown.set_default();
        };
        self.shutdown.as_mut().unwrap()
    }

    // Take field
    pub fn take_shutdown(&mut self) -> Call_Shutdown {
        self.shutdown.take().unwrap_or_else(|| Call_Shutdown::new())
    }

    pub fn get_shutdown<'a>(&'a self) -> &'a Call_Shutdown {
        self.shutdown.as_ref().unwrap_or_else(|| Call_Shutdown::default_instance())
    }

    // optional .mesos.v1.scheduler.Call.Acknowledge acknowledge = 8;

    pub fn clear_acknowledge(&mut self) {
        self.acknowledge.clear();
    }

    pub fn has_acknowledge(&self) -> bool {
        self.acknowledge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acknowledge(&mut self, v: Call_Acknowledge) {
        self.acknowledge = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_acknowledge<'a>(&'a mut self) -> &'a mut Call_Acknowledge {
        if self.acknowledge.is_none() {
            self.acknowledge.set_default();
        };
        self.acknowledge.as_mut().unwrap()
    }

    // Take field
    pub fn take_acknowledge(&mut self) -> Call_Acknowledge {
        self.acknowledge.take().unwrap_or_else(|| Call_Acknowledge::new())
    }

    pub fn get_acknowledge<'a>(&'a self) -> &'a Call_Acknowledge {
        self.acknowledge.as_ref().unwrap_or_else(|| Call_Acknowledge::default_instance())
    }

    // optional .mesos.v1.scheduler.Call.Reconcile reconcile = 9;

    pub fn clear_reconcile(&mut self) {
        self.reconcile.clear();
    }

    pub fn has_reconcile(&self) -> bool {
        self.reconcile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reconcile(&mut self, v: Call_Reconcile) {
        self.reconcile = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reconcile<'a>(&'a mut self) -> &'a mut Call_Reconcile {
        if self.reconcile.is_none() {
            self.reconcile.set_default();
        };
        self.reconcile.as_mut().unwrap()
    }

    // Take field
    pub fn take_reconcile(&mut self) -> Call_Reconcile {
        self.reconcile.take().unwrap_or_else(|| Call_Reconcile::new())
    }

    pub fn get_reconcile<'a>(&'a self) -> &'a Call_Reconcile {
        self.reconcile.as_ref().unwrap_or_else(|| Call_Reconcile::default_instance())
    }

    // optional .mesos.v1.scheduler.Call.Message message = 10;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: Call_Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message<'a>(&'a mut self) -> &'a mut Call_Message {
        if self.message.is_none() {
            self.message.set_default();
        };
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> Call_Message {
        self.message.take().unwrap_or_else(|| Call_Message::new())
    }

    pub fn get_message<'a>(&'a self) -> &'a Call_Message {
        self.message.as_ref().unwrap_or_else(|| Call_Message::default_instance())
    }

    // optional .mesos.v1.scheduler.Call.Request request = 11;

    pub fn clear_request(&mut self) {
        self.request.clear();
    }

    pub fn has_request(&self) -> bool {
        self.request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request(&mut self, v: Call_Request) {
        self.request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request<'a>(&'a mut self) -> &'a mut Call_Request {
        if self.request.is_none() {
            self.request.set_default();
        };
        self.request.as_mut().unwrap()
    }

    // Take field
    pub fn take_request(&mut self) -> Call_Request {
        self.request.take().unwrap_or_else(|| Call_Request::new())
    }

    pub fn get_request<'a>(&'a self) -> &'a Call_Request {
        self.request.as_ref().unwrap_or_else(|| Call_Request::default_instance())
    }
}

impl ::protobuf::Message for Call {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.framework_id.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.subscribe.set_default();
                    try!(is.merge_message(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.accept.set_default();
                    try!(is.merge_message(tmp))
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.decline.set_default();
                    try!(is.merge_message(tmp))
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.kill.set_default();
                    try!(is.merge_message(tmp))
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.shutdown.set_default();
                    try!(is.merge_message(tmp))
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.acknowledge.set_default();
                    try!(is.merge_message(tmp))
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.reconcile.set_default();
                    try!(is.merge_message(tmp))
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.message.set_default();
                    try!(is.merge_message(tmp))
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.request.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.framework_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        for value in self.subscribe.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.accept.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.decline.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.kill.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.shutdown.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.acknowledge.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.reconcile.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.message.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.request.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.framework_id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.field_type {
            try!(os.write_enum(2, v as i32));
        };
        if let Some(v) = self.subscribe.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.accept.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.decline.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.kill.as_ref() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.shutdown.as_ref() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.acknowledge.as_ref() {
            try!(os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.reconcile.as_ref() {
            try!(os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.message.as_ref() {
            try!(os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.request.as_ref() {
            try!(os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Call>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Call {
    fn new() -> Call {
        Call::new()
    }

    fn descriptor_static(_: ::std::option::Option<Call>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "framework_id",
                    Call::has_framework_id,
                    Call::get_framework_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "field_type",
                    Call::has_field_type,
                    Call::get_field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "subscribe",
                    Call::has_subscribe,
                    Call::get_subscribe,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "accept",
                    Call::has_accept,
                    Call::get_accept,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "decline",
                    Call::has_decline,
                    Call::get_decline,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "kill",
                    Call::has_kill,
                    Call::get_kill,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "shutdown",
                    Call::has_shutdown,
                    Call::get_shutdown,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "acknowledge",
                    Call::has_acknowledge,
                    Call::get_acknowledge,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "reconcile",
                    Call::has_reconcile,
                    Call::get_reconcile,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "message",
                    Call::has_message,
                    Call::get_message,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "request",
                    Call::has_request,
                    Call::get_request,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Call>(
                    "Call",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Call {
    fn clear(&mut self) {
        self.clear_framework_id();
        self.clear_field_type();
        self.clear_subscribe();
        self.clear_accept();
        self.clear_decline();
        self.clear_kill();
        self.clear_shutdown();
        self.clear_acknowledge();
        self.clear_reconcile();
        self.clear_message();
        self.clear_request();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Call {
    fn eq(&self, other: &Call) -> bool {
        self.framework_id == other.framework_id &&
        self.field_type == other.field_type &&
        self.subscribe == other.subscribe &&
        self.accept == other.accept &&
        self.decline == other.decline &&
        self.kill == other.kill &&
        self.shutdown == other.shutdown &&
        self.acknowledge == other.acknowledge &&
        self.reconcile == other.reconcile &&
        self.message == other.message &&
        self.request == other.request &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Call {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Call_Subscribe {
    // message fields
    framework_info: ::protobuf::SingularPtrField<FrameworkInfo>,
    force: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Call_Subscribe {
    pub fn new() -> Call_Subscribe {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Call_Subscribe {
        static mut instance: ::protobuf::lazy::Lazy<Call_Subscribe> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Call_Subscribe,
        };
        unsafe {
            instance.get(|| {
                Call_Subscribe {
                    framework_info: ::protobuf::SingularPtrField::none(),
                    force: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.FrameworkInfo framework_info = 1;

    pub fn clear_framework_info(&mut self) {
        self.framework_info.clear();
    }

    pub fn has_framework_info(&self) -> bool {
        self.framework_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framework_info(&mut self, v: FrameworkInfo) {
        self.framework_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_framework_info<'a>(&'a mut self) -> &'a mut FrameworkInfo {
        if self.framework_info.is_none() {
            self.framework_info.set_default();
        };
        self.framework_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_framework_info(&mut self) -> FrameworkInfo {
        self.framework_info.take().unwrap_or_else(|| FrameworkInfo::new())
    }

    pub fn get_framework_info<'a>(&'a self) -> &'a FrameworkInfo {
        self.framework_info.as_ref().unwrap_or_else(|| FrameworkInfo::default_instance())
    }

    // optional bool force = 2;

    pub fn clear_force(&mut self) {
        self.force = ::std::option::Option::None;
    }

    pub fn has_force(&self) -> bool {
        self.force.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = ::std::option::Option::Some(v);
    }

    pub fn get_force<'a>(&self) -> bool {
        self.force.unwrap_or(false)
    }
}

impl ::protobuf::Message for Call_Subscribe {
    fn is_initialized(&self) -> bool {
        if self.framework_info.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.framework_info.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.force = ::std::option::Option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.framework_info.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.force.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.framework_info.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.force {
            try!(os.write_bool(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Call_Subscribe>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Call_Subscribe {
    fn new() -> Call_Subscribe {
        Call_Subscribe::new()
    }

    fn descriptor_static(_: ::std::option::Option<Call_Subscribe>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "framework_info",
                    Call_Subscribe::has_framework_info,
                    Call_Subscribe::get_framework_info,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "force",
                    Call_Subscribe::has_force,
                    Call_Subscribe::get_force,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Call_Subscribe>(
                    "Call_Subscribe",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Call_Subscribe {
    fn clear(&mut self) {
        self.clear_framework_info();
        self.clear_force();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Call_Subscribe {
    fn eq(&self, other: &Call_Subscribe) -> bool {
        self.framework_info == other.framework_info &&
        self.force == other.force &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Call_Subscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Call_Accept {
    // message fields
    offer_ids: ::protobuf::RepeatedField<OfferID>,
    operations: ::protobuf::RepeatedField<Operation>,
    filters: ::protobuf::SingularPtrField<Filters>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Call_Accept {
    pub fn new() -> Call_Accept {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Call_Accept {
        static mut instance: ::protobuf::lazy::Lazy<Call_Accept> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Call_Accept,
        };
        unsafe {
            instance.get(|| {
                Call_Accept {
                    offer_ids: ::protobuf::RepeatedField::new(),
                    operations: ::protobuf::RepeatedField::new(),
                    filters: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.OfferID offer_ids = 1;

    pub fn clear_offer_ids(&mut self) {
        self.offer_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_offer_ids(&mut self, v: ::protobuf::RepeatedField<OfferID>) {
        self.offer_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_offer_ids<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<OfferID> {
        &mut self.offer_ids
    }

    // Take field
    pub fn take_offer_ids(&mut self) -> ::protobuf::RepeatedField<OfferID> {
        ::std::mem::replace(&mut self.offer_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_offer_ids<'a>(&'a self) -> &'a [OfferID] {
        &self.offer_ids
    }

    // repeated .mesos.v1.Offer.Operation operations = 2;

    pub fn clear_operations(&mut self) {
        self.operations.clear();
    }

    // Param is passed by value, moved
    pub fn set_operations(&mut self, v: ::protobuf::RepeatedField<Operation>) {
        self.operations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operations<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Operation> {
        &mut self.operations
    }

    // Take field
    pub fn take_operations(&mut self) -> ::protobuf::RepeatedField<Operation> {
        ::std::mem::replace(&mut self.operations, ::protobuf::RepeatedField::new())
    }

    pub fn get_operations<'a>(&'a self) -> &'a [Operation] {
        &self.operations
    }

    // optional .mesos.v1.Filters filters = 3;

    pub fn clear_filters(&mut self) {
        self.filters.clear();
    }

    pub fn has_filters(&self) -> bool {
        self.filters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filters(&mut self, v: Filters) {
        self.filters = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filters<'a>(&'a mut self) -> &'a mut Filters {
        if self.filters.is_none() {
            self.filters.set_default();
        };
        self.filters.as_mut().unwrap()
    }

    // Take field
    pub fn take_filters(&mut self) -> Filters {
        self.filters.take().unwrap_or_else(|| Filters::new())
    }

    pub fn get_filters<'a>(&'a self) -> &'a Filters {
        self.filters.as_ref().unwrap_or_else(|| Filters::default_instance())
    }
}

impl ::protobuf::Message for Call_Accept {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.offer_ids));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.operations));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.filters.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.offer_ids.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.operations.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.filters.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.offer_ids.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.operations.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.filters.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Call_Accept>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Call_Accept {
    fn new() -> Call_Accept {
        Call_Accept::new()
    }

    fn descriptor_static(_: ::std::option::Option<Call_Accept>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "offer_ids",
                    Call_Accept::get_offer_ids,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "operations",
                    Call_Accept::get_operations,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "filters",
                    Call_Accept::has_filters,
                    Call_Accept::get_filters,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Call_Accept>(
                    "Call_Accept",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Call_Accept {
    fn clear(&mut self) {
        self.clear_offer_ids();
        self.clear_operations();
        self.clear_filters();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Call_Accept {
    fn eq(&self, other: &Call_Accept) -> bool {
        self.offer_ids == other.offer_ids &&
        self.operations == other.operations &&
        self.filters == other.filters &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Call_Accept {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Call_Decline {
    // message fields
    offer_ids: ::protobuf::RepeatedField<OfferID>,
    filters: ::protobuf::SingularPtrField<Filters>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Call_Decline {
    pub fn new() -> Call_Decline {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Call_Decline {
        static mut instance: ::protobuf::lazy::Lazy<Call_Decline> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Call_Decline,
        };
        unsafe {
            instance.get(|| {
                Call_Decline {
                    offer_ids: ::protobuf::RepeatedField::new(),
                    filters: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.OfferID offer_ids = 1;

    pub fn clear_offer_ids(&mut self) {
        self.offer_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_offer_ids(&mut self, v: ::protobuf::RepeatedField<OfferID>) {
        self.offer_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_offer_ids<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<OfferID> {
        &mut self.offer_ids
    }

    // Take field
    pub fn take_offer_ids(&mut self) -> ::protobuf::RepeatedField<OfferID> {
        ::std::mem::replace(&mut self.offer_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_offer_ids<'a>(&'a self) -> &'a [OfferID] {
        &self.offer_ids
    }

    // optional .mesos.v1.Filters filters = 2;

    pub fn clear_filters(&mut self) {
        self.filters.clear();
    }

    pub fn has_filters(&self) -> bool {
        self.filters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filters(&mut self, v: Filters) {
        self.filters = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filters<'a>(&'a mut self) -> &'a mut Filters {
        if self.filters.is_none() {
            self.filters.set_default();
        };
        self.filters.as_mut().unwrap()
    }

    // Take field
    pub fn take_filters(&mut self) -> Filters {
        self.filters.take().unwrap_or_else(|| Filters::new())
    }

    pub fn get_filters<'a>(&'a self) -> &'a Filters {
        self.filters.as_ref().unwrap_or_else(|| Filters::default_instance())
    }
}

impl ::protobuf::Message for Call_Decline {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.offer_ids));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.filters.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.offer_ids.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.filters.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.offer_ids.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.filters.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Call_Decline>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Call_Decline {
    fn new() -> Call_Decline {
        Call_Decline::new()
    }

    fn descriptor_static(_: ::std::option::Option<Call_Decline>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "offer_ids",
                    Call_Decline::get_offer_ids,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "filters",
                    Call_Decline::has_filters,
                    Call_Decline::get_filters,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Call_Decline>(
                    "Call_Decline",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Call_Decline {
    fn clear(&mut self) {
        self.clear_offer_ids();
        self.clear_filters();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Call_Decline {
    fn eq(&self, other: &Call_Decline) -> bool {
        self.offer_ids == other.offer_ids &&
        self.filters == other.filters &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Call_Decline {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Call_Kill {
    // message fields
    task_id: ::protobuf::SingularPtrField<TaskID>,
    agent_id: ::protobuf::SingularPtrField<AgentID>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Call_Kill {
    pub fn new() -> Call_Kill {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Call_Kill {
        static mut instance: ::protobuf::lazy::Lazy<Call_Kill> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Call_Kill,
        };
        unsafe {
            instance.get(|| {
                Call_Kill {
                    task_id: ::protobuf::SingularPtrField::none(),
                    agent_id: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.TaskID task_id = 1;

    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    pub fn has_task_id(&self) -> bool {
        self.task_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: TaskID) {
        self.task_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id<'a>(&'a mut self) -> &'a mut TaskID {
        if self.task_id.is_none() {
            self.task_id.set_default();
        };
        self.task_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_task_id(&mut self) -> TaskID {
        self.task_id.take().unwrap_or_else(|| TaskID::new())
    }

    pub fn get_task_id<'a>(&'a self) -> &'a TaskID {
        self.task_id.as_ref().unwrap_or_else(|| TaskID::default_instance())
    }

    // optional .mesos.v1.AgentID agent_id = 2;

    pub fn clear_agent_id(&mut self) {
        self.agent_id.clear();
    }

    pub fn has_agent_id(&self) -> bool {
        self.agent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_id(&mut self, v: AgentID) {
        self.agent_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_id<'a>(&'a mut self) -> &'a mut AgentID {
        if self.agent_id.is_none() {
            self.agent_id.set_default();
        };
        self.agent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_id(&mut self) -> AgentID {
        self.agent_id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_agent_id<'a>(&'a self) -> &'a AgentID {
        self.agent_id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }
}

impl ::protobuf::Message for Call_Kill {
    fn is_initialized(&self) -> bool {
        if self.task_id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.task_id.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.agent_id.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.task_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.agent_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.task_id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.agent_id.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Call_Kill>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Call_Kill {
    fn new() -> Call_Kill {
        Call_Kill::new()
    }

    fn descriptor_static(_: ::std::option::Option<Call_Kill>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "task_id",
                    Call_Kill::has_task_id,
                    Call_Kill::get_task_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "agent_id",
                    Call_Kill::has_agent_id,
                    Call_Kill::get_agent_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Call_Kill>(
                    "Call_Kill",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Call_Kill {
    fn clear(&mut self) {
        self.clear_task_id();
        self.clear_agent_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Call_Kill {
    fn eq(&self, other: &Call_Kill) -> bool {
        self.task_id == other.task_id &&
        self.agent_id == other.agent_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Call_Kill {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Call_Shutdown {
    // message fields
    executor_id: ::protobuf::SingularPtrField<ExecutorID>,
    agent_id: ::protobuf::SingularPtrField<AgentID>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Call_Shutdown {
    pub fn new() -> Call_Shutdown {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Call_Shutdown {
        static mut instance: ::protobuf::lazy::Lazy<Call_Shutdown> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Call_Shutdown,
        };
        unsafe {
            instance.get(|| {
                Call_Shutdown {
                    executor_id: ::protobuf::SingularPtrField::none(),
                    agent_id: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.ExecutorID executor_id = 1;

    pub fn clear_executor_id(&mut self) {
        self.executor_id.clear();
    }

    pub fn has_executor_id(&self) -> bool {
        self.executor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executor_id(&mut self, v: ExecutorID) {
        self.executor_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executor_id<'a>(&'a mut self) -> &'a mut ExecutorID {
        if self.executor_id.is_none() {
            self.executor_id.set_default();
        };
        self.executor_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_executor_id(&mut self) -> ExecutorID {
        self.executor_id.take().unwrap_or_else(|| ExecutorID::new())
    }

    pub fn get_executor_id<'a>(&'a self) -> &'a ExecutorID {
        self.executor_id.as_ref().unwrap_or_else(|| ExecutorID::default_instance())
    }

    // required .mesos.v1.AgentID agent_id = 2;

    pub fn clear_agent_id(&mut self) {
        self.agent_id.clear();
    }

    pub fn has_agent_id(&self) -> bool {
        self.agent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_id(&mut self, v: AgentID) {
        self.agent_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_id<'a>(&'a mut self) -> &'a mut AgentID {
        if self.agent_id.is_none() {
            self.agent_id.set_default();
        };
        self.agent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_id(&mut self) -> AgentID {
        self.agent_id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_agent_id<'a>(&'a self) -> &'a AgentID {
        self.agent_id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }
}

impl ::protobuf::Message for Call_Shutdown {
    fn is_initialized(&self) -> bool {
        if self.executor_id.is_none() {
            return false;
        };
        if self.agent_id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.executor_id.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.agent_id.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.executor_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.agent_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.executor_id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.agent_id.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Call_Shutdown>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Call_Shutdown {
    fn new() -> Call_Shutdown {
        Call_Shutdown::new()
    }

    fn descriptor_static(_: ::std::option::Option<Call_Shutdown>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "executor_id",
                    Call_Shutdown::has_executor_id,
                    Call_Shutdown::get_executor_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "agent_id",
                    Call_Shutdown::has_agent_id,
                    Call_Shutdown::get_agent_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Call_Shutdown>(
                    "Call_Shutdown",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Call_Shutdown {
    fn clear(&mut self) {
        self.clear_executor_id();
        self.clear_agent_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Call_Shutdown {
    fn eq(&self, other: &Call_Shutdown) -> bool {
        self.executor_id == other.executor_id &&
        self.agent_id == other.agent_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Call_Shutdown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Call_Acknowledge {
    // message fields
    agent_id: ::protobuf::SingularPtrField<AgentID>,
    task_id: ::protobuf::SingularPtrField<TaskID>,
    uuid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Call_Acknowledge {
    pub fn new() -> Call_Acknowledge {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Call_Acknowledge {
        static mut instance: ::protobuf::lazy::Lazy<Call_Acknowledge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Call_Acknowledge,
        };
        unsafe {
            instance.get(|| {
                Call_Acknowledge {
                    agent_id: ::protobuf::SingularPtrField::none(),
                    task_id: ::protobuf::SingularPtrField::none(),
                    uuid: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.AgentID agent_id = 1;

    pub fn clear_agent_id(&mut self) {
        self.agent_id.clear();
    }

    pub fn has_agent_id(&self) -> bool {
        self.agent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_id(&mut self, v: AgentID) {
        self.agent_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_id<'a>(&'a mut self) -> &'a mut AgentID {
        if self.agent_id.is_none() {
            self.agent_id.set_default();
        };
        self.agent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_id(&mut self) -> AgentID {
        self.agent_id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_agent_id<'a>(&'a self) -> &'a AgentID {
        self.agent_id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }

    // required .mesos.v1.TaskID task_id = 2;

    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    pub fn has_task_id(&self) -> bool {
        self.task_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: TaskID) {
        self.task_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id<'a>(&'a mut self) -> &'a mut TaskID {
        if self.task_id.is_none() {
            self.task_id.set_default();
        };
        self.task_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_task_id(&mut self) -> TaskID {
        self.task_id.take().unwrap_or_else(|| TaskID::new())
    }

    pub fn get_task_id<'a>(&'a self) -> &'a TaskID {
        self.task_id.as_ref().unwrap_or_else(|| TaskID::default_instance())
    }

    // required bytes uuid = 3;

    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    pub fn has_uuid(&self) -> bool {
        self.uuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::vec::Vec<u8>) {
        self.uuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.uuid.is_none() {
            self.uuid.set_default();
        };
        self.uuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::vec::Vec<u8> {
        self.uuid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_uuid<'a>(&'a self) -> &'a [u8] {
        match self.uuid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for Call_Acknowledge {
    fn is_initialized(&self) -> bool {
        if self.agent_id.is_none() {
            return false;
        };
        if self.task_id.is_none() {
            return false;
        };
        if self.uuid.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.agent_id.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.task_id.set_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.uuid.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.agent_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.task_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.uuid.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.agent_id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.task_id.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.uuid.as_ref() {
            try!(os.write_bytes(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Call_Acknowledge>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Call_Acknowledge {
    fn new() -> Call_Acknowledge {
        Call_Acknowledge::new()
    }

    fn descriptor_static(_: ::std::option::Option<Call_Acknowledge>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "agent_id",
                    Call_Acknowledge::has_agent_id,
                    Call_Acknowledge::get_agent_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "task_id",
                    Call_Acknowledge::has_task_id,
                    Call_Acknowledge::get_task_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "uuid",
                    Call_Acknowledge::has_uuid,
                    Call_Acknowledge::get_uuid,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Call_Acknowledge>(
                    "Call_Acknowledge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Call_Acknowledge {
    fn clear(&mut self) {
        self.clear_agent_id();
        self.clear_task_id();
        self.clear_uuid();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Call_Acknowledge {
    fn eq(&self, other: &Call_Acknowledge) -> bool {
        self.agent_id == other.agent_id &&
        self.task_id == other.task_id &&
        self.uuid == other.uuid &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Call_Acknowledge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Call_Reconcile {
    // message fields
    tasks: ::protobuf::RepeatedField<Call_Reconcile_Task>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Call_Reconcile {
    pub fn new() -> Call_Reconcile {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Call_Reconcile {
        static mut instance: ::protobuf::lazy::Lazy<Call_Reconcile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Call_Reconcile,
        };
        unsafe {
            instance.get(|| {
                Call_Reconcile {
                    tasks: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.scheduler.Call.Reconcile.Task tasks = 1;

    pub fn clear_tasks(&mut self) {
        self.tasks.clear();
    }

    // Param is passed by value, moved
    pub fn set_tasks(&mut self, v: ::protobuf::RepeatedField<Call_Reconcile_Task>) {
        self.tasks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tasks<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Call_Reconcile_Task> {
        &mut self.tasks
    }

    // Take field
    pub fn take_tasks(&mut self) -> ::protobuf::RepeatedField<Call_Reconcile_Task> {
        ::std::mem::replace(&mut self.tasks, ::protobuf::RepeatedField::new())
    }

    pub fn get_tasks<'a>(&'a self) -> &'a [Call_Reconcile_Task] {
        &self.tasks
    }
}

impl ::protobuf::Message for Call_Reconcile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tasks));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.tasks.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.tasks.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Call_Reconcile>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Call_Reconcile {
    fn new() -> Call_Reconcile {
        Call_Reconcile::new()
    }

    fn descriptor_static(_: ::std::option::Option<Call_Reconcile>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "tasks",
                    Call_Reconcile::get_tasks,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Call_Reconcile>(
                    "Call_Reconcile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Call_Reconcile {
    fn clear(&mut self) {
        self.clear_tasks();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Call_Reconcile {
    fn eq(&self, other: &Call_Reconcile) -> bool {
        self.tasks == other.tasks &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Call_Reconcile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Call_Reconcile_Task {
    // message fields
    task_id: ::protobuf::SingularPtrField<TaskID>,
    agent_id: ::protobuf::SingularPtrField<AgentID>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Call_Reconcile_Task {
    pub fn new() -> Call_Reconcile_Task {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Call_Reconcile_Task {
        static mut instance: ::protobuf::lazy::Lazy<Call_Reconcile_Task> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Call_Reconcile_Task,
        };
        unsafe {
            instance.get(|| {
                Call_Reconcile_Task {
                    task_id: ::protobuf::SingularPtrField::none(),
                    agent_id: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.TaskID task_id = 1;

    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    pub fn has_task_id(&self) -> bool {
        self.task_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: TaskID) {
        self.task_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id<'a>(&'a mut self) -> &'a mut TaskID {
        if self.task_id.is_none() {
            self.task_id.set_default();
        };
        self.task_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_task_id(&mut self) -> TaskID {
        self.task_id.take().unwrap_or_else(|| TaskID::new())
    }

    pub fn get_task_id<'a>(&'a self) -> &'a TaskID {
        self.task_id.as_ref().unwrap_or_else(|| TaskID::default_instance())
    }

    // optional .mesos.v1.AgentID agent_id = 2;

    pub fn clear_agent_id(&mut self) {
        self.agent_id.clear();
    }

    pub fn has_agent_id(&self) -> bool {
        self.agent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_id(&mut self, v: AgentID) {
        self.agent_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_id<'a>(&'a mut self) -> &'a mut AgentID {
        if self.agent_id.is_none() {
            self.agent_id.set_default();
        };
        self.agent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_id(&mut self) -> AgentID {
        self.agent_id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_agent_id<'a>(&'a self) -> &'a AgentID {
        self.agent_id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }
}

impl ::protobuf::Message for Call_Reconcile_Task {
    fn is_initialized(&self) -> bool {
        if self.task_id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.task_id.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.agent_id.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.task_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.agent_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.task_id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.agent_id.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Call_Reconcile_Task>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Call_Reconcile_Task {
    fn new() -> Call_Reconcile_Task {
        Call_Reconcile_Task::new()
    }

    fn descriptor_static(_: ::std::option::Option<Call_Reconcile_Task>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "task_id",
                    Call_Reconcile_Task::has_task_id,
                    Call_Reconcile_Task::get_task_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "agent_id",
                    Call_Reconcile_Task::has_agent_id,
                    Call_Reconcile_Task::get_agent_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Call_Reconcile_Task>(
                    "Call_Reconcile_Task",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Call_Reconcile_Task {
    fn clear(&mut self) {
        self.clear_task_id();
        self.clear_agent_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Call_Reconcile_Task {
    fn eq(&self, other: &Call_Reconcile_Task) -> bool {
        self.task_id == other.task_id &&
        self.agent_id == other.agent_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Call_Reconcile_Task {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Call_Message {
    // message fields
    agent_id: ::protobuf::SingularPtrField<AgentID>,
    executor_id: ::protobuf::SingularPtrField<ExecutorID>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Call_Message {
    pub fn new() -> Call_Message {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Call_Message {
        static mut instance: ::protobuf::lazy::Lazy<Call_Message> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Call_Message,
        };
        unsafe {
            instance.get(|| {
                Call_Message {
                    agent_id: ::protobuf::SingularPtrField::none(),
                    executor_id: ::protobuf::SingularPtrField::none(),
                    data: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.AgentID agent_id = 1;

    pub fn clear_agent_id(&mut self) {
        self.agent_id.clear();
    }

    pub fn has_agent_id(&self) -> bool {
        self.agent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_id(&mut self, v: AgentID) {
        self.agent_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_id<'a>(&'a mut self) -> &'a mut AgentID {
        if self.agent_id.is_none() {
            self.agent_id.set_default();
        };
        self.agent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_id(&mut self) -> AgentID {
        self.agent_id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_agent_id<'a>(&'a self) -> &'a AgentID {
        self.agent_id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }

    // required .mesos.v1.ExecutorID executor_id = 2;

    pub fn clear_executor_id(&mut self) {
        self.executor_id.clear();
    }

    pub fn has_executor_id(&self) -> bool {
        self.executor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executor_id(&mut self, v: ExecutorID) {
        self.executor_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executor_id<'a>(&'a mut self) -> &'a mut ExecutorID {
        if self.executor_id.is_none() {
            self.executor_id.set_default();
        };
        self.executor_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_executor_id(&mut self) -> ExecutorID {
        self.executor_id.take().unwrap_or_else(|| ExecutorID::new())
    }

    pub fn get_executor_id<'a>(&'a self) -> &'a ExecutorID {
        self.executor_id.as_ref().unwrap_or_else(|| ExecutorID::default_instance())
    }

    // required bytes data = 3;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        };
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data<'a>(&'a self) -> &'a [u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for Call_Message {
    fn is_initialized(&self) -> bool {
        if self.agent_id.is_none() {
            return false;
        };
        if self.executor_id.is_none() {
            return false;
        };
        if self.data.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.agent_id.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.executor_id.set_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.data.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.agent_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.executor_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.data.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.agent_id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.executor_id.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.data.as_ref() {
            try!(os.write_bytes(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Call_Message>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Call_Message {
    fn new() -> Call_Message {
        Call_Message::new()
    }

    fn descriptor_static(_: ::std::option::Option<Call_Message>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "agent_id",
                    Call_Message::has_agent_id,
                    Call_Message::get_agent_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "executor_id",
                    Call_Message::has_executor_id,
                    Call_Message::get_executor_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "data",
                    Call_Message::has_data,
                    Call_Message::get_data,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Call_Message>(
                    "Call_Message",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Call_Message {
    fn clear(&mut self) {
        self.clear_agent_id();
        self.clear_executor_id();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Call_Message {
    fn eq(&self, other: &Call_Message) -> bool {
        self.agent_id == other.agent_id &&
        self.executor_id == other.executor_id &&
        self.data == other.data &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Call_Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Call_Request {
    // message fields
    requests: ::protobuf::RepeatedField<Request>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Call_Request {
    pub fn new() -> Call_Request {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Call_Request {
        static mut instance: ::protobuf::lazy::Lazy<Call_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Call_Request,
        };
        unsafe {
            instance.get(|| {
                Call_Request {
                    requests: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.Request requests = 1;

    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::protobuf::RepeatedField<Request>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Request> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::protobuf::RepeatedField<Request> {
        ::std::mem::replace(&mut self.requests, ::protobuf::RepeatedField::new())
    }

    pub fn get_requests<'a>(&'a self) -> &'a [Request] {
        &self.requests
    }
}

impl ::protobuf::Message for Call_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.requests));
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.requests.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.requests.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Call_Request>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Call_Request {
    fn new() -> Call_Request {
        Call_Request::new()
    }

    fn descriptor_static(_: ::std::option::Option<Call_Request>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "requests",
                    Call_Request::get_requests,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Call_Request>(
                    "Call_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Call_Request {
    fn clear(&mut self) {
        self.clear_requests();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Call_Request {
    fn eq(&self, other: &Call_Request) -> bool {
        self.requests == other.requests &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Call_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Call_Type {
    SUBSCRIBE = 1,
    TEARDOWN = 2,
    ACCEPT = 3,
    DECLINE = 4,
    REVIVE = 5,
    KILL = 6,
    SHUTDOWN = 7,
    ACKNOWLEDGE = 8,
    RECONCILE = 9,
    MESSAGE = 10,
    REQUEST = 11,
    SUPPRESS = 12,
}

impl ::protobuf::ProtobufEnum for Call_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Call_Type> {
        match value {
            1 => ::std::option::Option::Some(Call_Type::SUBSCRIBE),
            2 => ::std::option::Option::Some(Call_Type::TEARDOWN),
            3 => ::std::option::Option::Some(Call_Type::ACCEPT),
            4 => ::std::option::Option::Some(Call_Type::DECLINE),
            5 => ::std::option::Option::Some(Call_Type::REVIVE),
            6 => ::std::option::Option::Some(Call_Type::KILL),
            7 => ::std::option::Option::Some(Call_Type::SHUTDOWN),
            8 => ::std::option::Option::Some(Call_Type::ACKNOWLEDGE),
            9 => ::std::option::Option::Some(Call_Type::RECONCILE),
            10 => ::std::option::Option::Some(Call_Type::MESSAGE),
            11 => ::std::option::Option::Some(Call_Type::REQUEST),
            12 => ::std::option::Option::Some(Call_Type::SUPPRESS),
            _ => ::std::option::Option::None
        }
    }

    fn enum_descriptor_static(_: Option<Call_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Call_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Call_Type {
}

static file_descriptor_proto_data: &'static [u8] = &[
    0x0a, 0x22, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2f, 0x76, 0x31, 0x2f, 0x73, 0x63, 0x68, 0x65, 0x64,
    0x75, 0x6c, 0x65, 0x72, 0x2f, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x70,
    0x72, 0x6f, 0x74, 0x6f, 0x12, 0x12, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x73,
    0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x1a, 0x14, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2f,
    0x76, 0x31, 0x2f, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x98,
    0x08, 0x0a, 0x05, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x2c, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65,
    0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x1e, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76,
    0x31, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x45, 0x76, 0x65, 0x6e,
    0x74, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x38, 0x0a, 0x0a, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72,
    0x69, 0x62, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x6d, 0x65, 0x73,
    0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e,
    0x45, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x64,
    0x12, 0x30, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
    0x32, 0x20, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x73, 0x63, 0x68, 0x65,
    0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x4f, 0x66, 0x66, 0x65,
    0x72, 0x73, 0x12, 0x32, 0x0a, 0x07, 0x72, 0x65, 0x73, 0x63, 0x69, 0x6e, 0x64, 0x18, 0x04, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x73,
    0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x52,
    0x65, 0x73, 0x63, 0x69, 0x6e, 0x64, 0x12, 0x30, 0x0a, 0x06, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65,
    0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76,
    0x31, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x45, 0x76, 0x65, 0x6e,
    0x74, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x12, 0x32, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73,
    0x61, 0x67, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x6d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x76, 0x31, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x45,
    0x76, 0x65, 0x6e, 0x74, 0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x32, 0x0a, 0x07,
    0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e,
    0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c,
    0x65, 0x72, 0x2e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65,
    0x12, 0x2e, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x1f, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64,
    0x75, 0x6c, 0x65, 0x72, 0x2e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72,
    0x1a, 0x5d, 0x0a, 0x0a, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x64, 0x12, 0x2b,
    0x0a, 0x0c, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x5f, 0x69, 0x64, 0x18, 0x01,
    0x20, 0x02, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e,
    0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x44, 0x12, 0x22, 0x0a, 0x1a, 0x68,
    0x65, 0x61, 0x72, 0x74, 0x62, 0x65, 0x61, 0x74, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61,
    0x6c, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x1a,
    0x59, 0x0a, 0x06, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x73, 0x12, 0x1f, 0x0a, 0x06, 0x6f, 0x66, 0x66,
    0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x12, 0x2e, 0x0a, 0x0e, 0x69, 0x6e,
    0x76, 0x65, 0x72, 0x73, 0x65, 0x5f, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x03,
    0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6e,
    0x76, 0x65, 0x72, 0x73, 0x65, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x1a, 0x2e, 0x0a, 0x07, 0x52, 0x65,
    0x73, 0x63, 0x69, 0x6e, 0x64, 0x12, 0x23, 0x0a, 0x08, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x5f, 0x69,
    0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e,
    0x76, 0x31, 0x2e, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x49, 0x44, 0x1a, 0x2e, 0x0a, 0x06, 0x55, 0x70,
    0x64, 0x61, 0x74, 0x65, 0x12, 0x24, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01,
    0x20, 0x02, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e,
    0x54, 0x61, 0x73, 0x6b, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x1a, 0x67, 0x0a, 0x07, 0x4d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x23, 0x0a, 0x08, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x5f, 0x69,
    0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e,
    0x76, 0x31, 0x2e, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x49, 0x44, 0x12, 0x29, 0x0a, 0x0b, 0x65, 0x78,
    0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0b, 0x32,
    0x14, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78, 0x65, 0x63, 0x75,
    0x74, 0x6f, 0x72, 0x49, 0x44, 0x12, 0x0c, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x03, 0x20,
    0x02, 0x28, 0x0c, 0x1a, 0x69, 0x0a, 0x07, 0x46, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x12, 0x23,
    0x0a, 0x08, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
    0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x67, 0x65, 0x6e,
    0x74, 0x49, 0x44, 0x12, 0x29, 0x0a, 0x0b, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x5f,
    0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73,
    0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x49, 0x44, 0x12, 0x0e,
    0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x1a, 0x18,
    0x0a, 0x05, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x12, 0x0f, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61,
    0x67, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x6f, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65,
    0x12, 0x0e, 0x0a, 0x0a, 0x53, 0x55, 0x42, 0x53, 0x43, 0x52, 0x49, 0x42, 0x45, 0x44, 0x10, 0x01,
    0x12, 0x0a, 0x0a, 0x06, 0x4f, 0x46, 0x46, 0x45, 0x52, 0x53, 0x10, 0x02, 0x12, 0x0b, 0x0a, 0x07,
    0x52, 0x45, 0x53, 0x43, 0x49, 0x4e, 0x44, 0x10, 0x03, 0x12, 0x0a, 0x0a, 0x06, 0x55, 0x50, 0x44,
    0x41, 0x54, 0x45, 0x10, 0x04, 0x12, 0x0b, 0x0a, 0x07, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45,
    0x10, 0x05, 0x12, 0x0b, 0x0a, 0x07, 0x46, 0x41, 0x49, 0x4c, 0x55, 0x52, 0x45, 0x10, 0x06, 0x12,
    0x09, 0x0a, 0x05, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x10, 0x07, 0x12, 0x0d, 0x0a, 0x09, 0x48, 0x45,
    0x41, 0x52, 0x54, 0x42, 0x45, 0x41, 0x54, 0x10, 0x08, 0x22, 0xc6, 0x0c, 0x0a, 0x04, 0x43, 0x61,
    0x6c, 0x6c, 0x12, 0x2b, 0x0a, 0x0c, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x5f,
    0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73,
    0x2e, 0x76, 0x31, 0x2e, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x44, 0x12,
    0x2b, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x1d, 0x2e,
    0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c,
    0x65, 0x72, 0x2e, 0x43, 0x61, 0x6c, 0x6c, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x35, 0x0a, 0x09,
    0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x22, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64,
    0x75, 0x6c, 0x65, 0x72, 0x2e, 0x43, 0x61, 0x6c, 0x6c, 0x2e, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72,
    0x69, 0x62, 0x65, 0x12, 0x2f, 0x0a, 0x06, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x18, 0x04, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x73,
    0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x43, 0x61, 0x6c, 0x6c, 0x2e, 0x41, 0x63,
    0x63, 0x65, 0x70, 0x74, 0x12, 0x31, 0x0a, 0x07, 0x64, 0x65, 0x63, 0x6c, 0x69, 0x6e, 0x65, 0x18,
    0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31,
    0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x43, 0x61, 0x6c, 0x6c, 0x2e,
    0x44, 0x65, 0x63, 0x6c, 0x69, 0x6e, 0x65, 0x12, 0x2b, 0x0a, 0x04, 0x6b, 0x69, 0x6c, 0x6c, 0x18,
    0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31,
    0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x43, 0x61, 0x6c, 0x6c, 0x2e,
    0x4b, 0x69, 0x6c, 0x6c, 0x12, 0x33, 0x0a, 0x08, 0x73, 0x68, 0x75, 0x74, 0x64, 0x6f, 0x77, 0x6e,
    0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76,
    0x31, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x43, 0x61, 0x6c, 0x6c,
    0x2e, 0x53, 0x68, 0x75, 0x74, 0x64, 0x6f, 0x77, 0x6e, 0x12, 0x39, 0x0a, 0x0b, 0x61, 0x63, 0x6b,
    0x6e, 0x6f, 0x77, 0x6c, 0x65, 0x64, 0x67, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24,
    0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75,
    0x6c, 0x65, 0x72, 0x2e, 0x43, 0x61, 0x6c, 0x6c, 0x2e, 0x41, 0x63, 0x6b, 0x6e, 0x6f, 0x77, 0x6c,
    0x65, 0x64, 0x67, 0x65, 0x12, 0x35, 0x0a, 0x09, 0x72, 0x65, 0x63, 0x6f, 0x6e, 0x63, 0x69, 0x6c,
    0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e,
    0x76, 0x31, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x43, 0x61, 0x6c,
    0x6c, 0x2e, 0x52, 0x65, 0x63, 0x6f, 0x6e, 0x63, 0x69, 0x6c, 0x65, 0x12, 0x31, 0x0a, 0x07, 0x6d,
    0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
    0x72, 0x2e, 0x43, 0x61, 0x6c, 0x6c, 0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x31,
    0x0a, 0x07, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x20, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64,
    0x75, 0x6c, 0x65, 0x72, 0x2e, 0x43, 0x61, 0x6c, 0x6c, 0x2e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
    0x74, 0x1a, 0x4b, 0x0a, 0x09, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x12, 0x2f,
    0x0a, 0x0e, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x5f, 0x69, 0x6e, 0x66, 0x6f,
    0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76,
    0x31, 0x2e, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x12,
    0x0d, 0x0a, 0x05, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x1a, 0x81,
    0x01, 0x0a, 0x06, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x12, 0x24, 0x0a, 0x09, 0x6f, 0x66, 0x66,
    0x65, 0x72, 0x5f, 0x69, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x49, 0x44, 0x12,
    0x2d, 0x0a, 0x0a, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x02, 0x20,
    0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4f,
    0x66, 0x66, 0x65, 0x72, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x22,
    0x0a, 0x07, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x69, 0x6c, 0x74, 0x65,
    0x72, 0x73, 0x1a, 0x53, 0x0a, 0x07, 0x44, 0x65, 0x63, 0x6c, 0x69, 0x6e, 0x65, 0x12, 0x24, 0x0a,
    0x09, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
    0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x66, 0x66, 0x65,
    0x72, 0x49, 0x44, 0x12, 0x22, 0x0a, 0x07, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x18, 0x02,
    0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e,
    0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x1a, 0x4e, 0x0a, 0x04, 0x4b, 0x69, 0x6c, 0x6c, 0x12,
    0x21, 0x0a, 0x07, 0x74, 0x61, 0x73, 0x6b, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b,
    0x32, 0x10, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x61, 0x73, 0x6b,
    0x49, 0x44, 0x12, 0x23, 0x0a, 0x08, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x02,
    0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e,
    0x41, 0x67, 0x65, 0x6e, 0x74, 0x49, 0x44, 0x1a, 0x5a, 0x0a, 0x08, 0x53, 0x68, 0x75, 0x74, 0x64,
    0x6f, 0x77, 0x6e, 0x12, 0x29, 0x0a, 0x0b, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x5f,
    0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73,
    0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x49, 0x44, 0x12, 0x23,
    0x0a, 0x08, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0b,
    0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x67, 0x65, 0x6e,
    0x74, 0x49, 0x44, 0x1a, 0x63, 0x0a, 0x0b, 0x41, 0x63, 0x6b, 0x6e, 0x6f, 0x77, 0x6c, 0x65, 0x64,
    0x67, 0x65, 0x12, 0x23, 0x0a, 0x08, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01,
    0x20, 0x02, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e,
    0x41, 0x67, 0x65, 0x6e, 0x74, 0x49, 0x44, 0x12, 0x21, 0x0a, 0x07, 0x74, 0x61, 0x73, 0x6b, 0x5f,
    0x69, 0x64, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73,
    0x2e, 0x76, 0x31, 0x2e, 0x54, 0x61, 0x73, 0x6b, 0x49, 0x44, 0x12, 0x0c, 0x0a, 0x04, 0x75, 0x75,
    0x69, 0x64, 0x18, 0x03, 0x20, 0x02, 0x28, 0x0c, 0x1a, 0x93, 0x01, 0x0a, 0x09, 0x52, 0x65, 0x63,
    0x6f, 0x6e, 0x63, 0x69, 0x6c, 0x65, 0x12, 0x36, 0x0a, 0x05, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x18,
    0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31,
    0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x43, 0x61, 0x6c, 0x6c, 0x2e,
    0x52, 0x65, 0x63, 0x6f, 0x6e, 0x63, 0x69, 0x6c, 0x65, 0x2e, 0x54, 0x61, 0x73, 0x6b, 0x1a, 0x4e,
    0x0a, 0x04, 0x54, 0x61, 0x73, 0x6b, 0x12, 0x21, 0x0a, 0x07, 0x74, 0x61, 0x73, 0x6b, 0x5f, 0x69,
    0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e,
    0x76, 0x31, 0x2e, 0x54, 0x61, 0x73, 0x6b, 0x49, 0x44, 0x12, 0x23, 0x0a, 0x08, 0x61, 0x67, 0x65,
    0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x49, 0x44, 0x1a, 0x67,
    0x0a, 0x07, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x23, 0x0a, 0x08, 0x61, 0x67, 0x65,
    0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x49, 0x44, 0x12, 0x29,
    0x0a, 0x0b, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20,
    0x02, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x45,
    0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x49, 0x44, 0x12, 0x0c, 0x0a, 0x04, 0x64, 0x61, 0x74,
    0x61, 0x18, 0x03, 0x20, 0x02, 0x28, 0x0c, 0x1a, 0x2e, 0x0a, 0x07, 0x52, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x12, 0x23, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x18, 0x01,
    0x20, 0x03, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e,
    0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0xa8, 0x01, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65,
    0x12, 0x0d, 0x0a, 0x09, 0x53, 0x55, 0x42, 0x53, 0x43, 0x52, 0x49, 0x42, 0x45, 0x10, 0x01, 0x12,
    0x0c, 0x0a, 0x08, 0x54, 0x45, 0x41, 0x52, 0x44, 0x4f, 0x57, 0x4e, 0x10, 0x02, 0x12, 0x0a, 0x0a,
    0x06, 0x41, 0x43, 0x43, 0x45, 0x50, 0x54, 0x10, 0x03, 0x12, 0x0b, 0x0a, 0x07, 0x44, 0x45, 0x43,
    0x4c, 0x49, 0x4e, 0x45, 0x10, 0x04, 0x12, 0x0a, 0x0a, 0x06, 0x52, 0x45, 0x56, 0x49, 0x56, 0x45,
    0x10, 0x05, 0x12, 0x08, 0x0a, 0x04, 0x4b, 0x49, 0x4c, 0x4c, 0x10, 0x06, 0x12, 0x0c, 0x0a, 0x08,
    0x53, 0x48, 0x55, 0x54, 0x44, 0x4f, 0x57, 0x4e, 0x10, 0x07, 0x12, 0x0f, 0x0a, 0x0b, 0x41, 0x43,
    0x4b, 0x4e, 0x4f, 0x57, 0x4c, 0x45, 0x44, 0x47, 0x45, 0x10, 0x08, 0x12, 0x0d, 0x0a, 0x09, 0x52,
    0x45, 0x43, 0x4f, 0x4e, 0x43, 0x49, 0x4c, 0x45, 0x10, 0x09, 0x12, 0x0b, 0x0a, 0x07, 0x4d, 0x45,
    0x53, 0x53, 0x41, 0x47, 0x45, 0x10, 0x0a, 0x12, 0x0b, 0x0a, 0x07, 0x52, 0x45, 0x51, 0x55, 0x45,
    0x53, 0x54, 0x10, 0x0b, 0x12, 0x0c, 0x0a, 0x08, 0x53, 0x55, 0x50, 0x50, 0x52, 0x45, 0x53, 0x53,
    0x10, 0x0c, 0x42, 0x27, 0x0a, 0x1d, 0x6f, 0x72, 0x67, 0x2e, 0x61, 0x70, 0x61, 0x63, 0x68, 0x65,
    0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75,
    0x6c, 0x65, 0x72, 0x42, 0x06, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x4a, 0x8c, 0x74, 0x0a, 0x07,
    0x12, 0x05, 0x12, 0x00, 0xd2, 0x02, 0x01, 0x0a, 0x09, 0x0a, 0x02, 0x03, 0x00, 0x12, 0x03, 0x12,
    0x07, 0x1d, 0x0a, 0x08, 0x0a, 0x01, 0x02, 0x12, 0x03, 0x14, 0x08, 0x1a, 0x0a, 0x08, 0x0a, 0x01,
    0x08, 0x12, 0x03, 0x16, 0x00, 0x36, 0x0a, 0x0b, 0x0a, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x03,
    0x16, 0x00, 0x36, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x03, 0x16, 0x07,
    0x13, 0x0a, 0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x03, 0x16, 0x07, 0x13,
    0x0a, 0x0e, 0x0a, 0x07, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x16, 0x07, 0x13,
    0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x07, 0x12, 0x03, 0x16, 0x16, 0x35, 0x0a, 0x08,
    0x0a, 0x01, 0x08, 0x12, 0x03, 0x17, 0x00, 0x27, 0x0a, 0x0b, 0x0a, 0x04, 0x08, 0xe7, 0x07, 0x01,
    0x12, 0x03, 0x17, 0x00, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x12, 0x03,
    0x17, 0x07, 0x1b, 0x0a, 0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x00, 0x12, 0x03, 0x17,
    0x07, 0x1b, 0x0a, 0x0e, 0x0a, 0x07, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x00, 0x01, 0x12, 0x03, 0x17,
    0x07, 0x1b, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x01, 0x07, 0x12, 0x03, 0x17, 0x1e, 0x26,
    0x0a, 0xbd, 0x01, 0x0a, 0x02, 0x04, 0x00, 0x12, 0x05, 0x21, 0x00, 0x98, 0x01, 0x01, 0x1a, 0xaf,
    0x01, 0x2a, 0x0a, 0x20, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x65, 0x76,
    0x65, 0x6e, 0x74, 0x20, 0x41, 0x50, 0x49, 0x2e, 0x0a, 0x0a, 0x20, 0x41, 0x6e, 0x20, 0x65, 0x76,
    0x65, 0x6e, 0x74, 0x20, 0x69, 0x73, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x64,
    0x20, 0x75, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x6e, 0x64,
    0x61, 0x72, 0x64, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x20, 0x62, 0x75, 0x66,
    0x66, 0x65, 0x72, 0x20, 0x22, 0x75, 0x6e, 0x69, 0x6f, 0x6e, 0x22, 0x0a, 0x20, 0x74, 0x72, 0x69,
    0x63, 0x6b, 0x2c, 0x20, 0x73, 0x65, 0x65, 0x3a, 0x0a, 0x20, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a,
    0x2f, 0x2f, 0x64, 0x65, 0x76, 0x65, 0x6c, 0x6f, 0x70, 0x65, 0x72, 0x73, 0x2e, 0x67, 0x6f, 0x6f,
    0x67, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,
    0x2d, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x2f, 0x64, 0x6f, 0x63, 0x73, 0x2f, 0x74, 0x65,
    0x63, 0x68, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x73, 0x23, 0x75, 0x6e, 0x69, 0x6f, 0x6e, 0x2e, 0x0a,
    0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x00, 0x01, 0x12, 0x03, 0x21, 0x08, 0x0d, 0x0a, 0x55, 0x0a, 0x04,
    0x04, 0x00, 0x04, 0x00, 0x12, 0x04, 0x24, 0x02, 0x35, 0x03, 0x1a, 0x47, 0x20, 0x50, 0x6f, 0x73,
    0x73, 0x69, 0x62, 0x6c, 0x65, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65,
    0x73, 0x2c, 0x20, 0x66, 0x6f, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x6d,
    0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f,
    0x6e, 0x73, 0x20, 0x69, 0x66, 0x0a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x62, 0x6c,
    0x65, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x04, 0x00, 0x01, 0x12, 0x03, 0x24, 0x07,
    0x0b, 0x0a, 0x28, 0x0a, 0x06, 0x04, 0x00, 0x04, 0x00, 0x02, 0x00, 0x12, 0x03, 0x25, 0x04, 0x13,
    0x22, 0x19, 0x20, 0x53, 0x65, 0x65, 0x20, 0x27, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62,
    0x65, 0x64, 0x27, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x77, 0x2e, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04,
    0x00, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x25, 0x04, 0x0e, 0x0a, 0x0e, 0x0a, 0x07, 0x04,
    0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x03, 0x25, 0x11, 0x12, 0x0a, 0x24, 0x0a, 0x06, 0x04,
    0x00, 0x04, 0x00, 0x02, 0x01, 0x12, 0x03, 0x26, 0x04, 0x0f, 0x22, 0x15, 0x20, 0x53, 0x65, 0x65,
    0x20, 0x27, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x73, 0x27, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x77, 0x2e,
    0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x03, 0x26, 0x04,
    0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x03, 0x26, 0x0d,
    0x0e, 0x0a, 0x25, 0x0a, 0x06, 0x04, 0x00, 0x04, 0x00, 0x02, 0x02, 0x12, 0x03, 0x27, 0x04, 0x10,
    0x22, 0x16, 0x20, 0x53, 0x65, 0x65, 0x20, 0x27, 0x52, 0x65, 0x73, 0x63, 0x69, 0x6e, 0x64, 0x27,
    0x20, 0x62, 0x65, 0x6c, 0x6f, 0x77, 0x2e, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x04, 0x00,
    0x02, 0x02, 0x01, 0x12, 0x03, 0x27, 0x04, 0x0b, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x04, 0x00,
    0x02, 0x02, 0x02, 0x12, 0x03, 0x27, 0x0e, 0x0f, 0x0a, 0x24, 0x0a, 0x06, 0x04, 0x00, 0x04, 0x00,
    0x02, 0x03, 0x12, 0x03, 0x28, 0x04, 0x0f, 0x22, 0x15, 0x20, 0x53, 0x65, 0x65, 0x20, 0x27, 0x55,
    0x70, 0x64, 0x61, 0x74, 0x65, 0x27, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x77, 0x2e, 0x0a, 0x0a, 0x0e,
    0x0a, 0x07, 0x04, 0x00, 0x04, 0x00, 0x02, 0x03, 0x01, 0x12, 0x03, 0x28, 0x04, 0x0a, 0x0a, 0x0e,
    0x0a, 0x07, 0x04, 0x00, 0x04, 0x00, 0x02, 0x03, 0x02, 0x12, 0x03, 0x28, 0x0d, 0x0e, 0x0a, 0x25,
    0x0a, 0x06, 0x04, 0x00, 0x04, 0x00, 0x02, 0x04, 0x12, 0x03, 0x29, 0x04, 0x10, 0x22, 0x16, 0x20,
    0x53, 0x65, 0x65, 0x20, 0x27, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x27, 0x20, 0x62, 0x65,
    0x6c, 0x6f, 0x77, 0x2e, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x04, 0x00, 0x02, 0x04, 0x01,
    0x12, 0x03, 0x29, 0x04, 0x0b, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x04, 0x00, 0x02, 0x04, 0x02,
    0x12, 0x03, 0x29, 0x0e, 0x0f, 0x0a, 0x25, 0x0a, 0x06, 0x04, 0x00, 0x04, 0x00, 0x02, 0x05, 0x12,
    0x03, 0x2a, 0x04, 0x10, 0x22, 0x16, 0x20, 0x53, 0x65, 0x65, 0x20, 0x27, 0x46, 0x61, 0x69, 0x6c,
    0x75, 0x72, 0x65, 0x27, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x77, 0x2e, 0x0a, 0x0a, 0x0e, 0x0a, 0x07,
    0x04, 0x00, 0x04, 0x00, 0x02, 0x05, 0x01, 0x12, 0x03, 0x2a, 0x04, 0x0b, 0x0a, 0x0e, 0x0a, 0x07,
    0x04, 0x00, 0x04, 0x00, 0x02, 0x05, 0x02, 0x12, 0x03, 0x2a, 0x0e, 0x0f, 0x0a, 0x23, 0x0a, 0x06,
    0x04, 0x00, 0x04, 0x00, 0x02, 0x06, 0x12, 0x03, 0x2b, 0x04, 0x0e, 0x22, 0x14, 0x20, 0x53, 0x65,
    0x65, 0x20, 0x27, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x27, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x77, 0x2e,
    0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x04, 0x00, 0x02, 0x06, 0x01, 0x12, 0x03, 0x2b, 0x04,
    0x09, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x04, 0x00, 0x02, 0x06, 0x02, 0x12, 0x03, 0x2b, 0x0c,
    0x0d, 0x0a, 0xa0, 0x03, 0x0a, 0x06, 0x04, 0x00, 0x04, 0x00, 0x02, 0x07, 0x12, 0x03, 0x34, 0x04,
    0x12, 0x1a, 0x90, 0x03, 0x20, 0x50, 0x65, 0x72, 0x69, 0x6f, 0x64, 0x69, 0x63, 0x20, 0x6d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x61,
    0x63, 0x63, 0x6f, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x27, 0x53, 0x75,
    0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x64, 0x2e, 0x68, 0x65, 0x61, 0x72, 0x74, 0x62, 0x65,
    0x61, 0x74, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x5f, 0x73, 0x65, 0x63, 0x6f,
    0x6e, 0x64, 0x73, 0x27, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x63, 0x68,
    0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x64, 0x6f, 0x65, 0x73, 0x0a, 0x20, 0x6e, 0x6f, 0x74,
    0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x65, 0x76, 0x65,
    0x6e, 0x74, 0x73, 0x20, 0x28, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x68,
    0x65, 0x61, 0x72, 0x74, 0x62, 0x65, 0x61, 0x74, 0x73, 0x29, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61,
    0x6e, 0x20, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x64, 0x65, 0x64, 0x0a, 0x20, 0x70, 0x65, 0x72, 0x69,
    0x6f, 0x64, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x28, 0x65, 0x2e, 0x67, 0x2e,
    0x2c, 0x20, 0x35, 0x20, 0x78, 0x20, 0x68, 0x65, 0x61, 0x72, 0x74, 0x62, 0x65, 0x61, 0x74, 0x5f,
    0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73,
    0x29, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x69, 0x73, 0x0a, 0x20, 0x6c, 0x69, 0x6b,
    0x65, 0x6c, 0x79, 0x20, 0x61, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x70, 0x61,
    0x72, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x20, 0x49, 0x6e, 0x20, 0x73, 0x75, 0x63, 0x68,
    0x20, 0x61, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65,
    0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x0a, 0x20, 0x63, 0x6c,
    0x6f, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67,
    0x20, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x63, 0x6f,
    0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x72, 0x65, 0x73,
    0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x0a, 0x20, 0x75, 0x73, 0x69, 0x6e, 0x67, 0x20,
    0x61, 0x20, 0x62, 0x61, 0x63, 0x6b, 0x6f, 0x66, 0x66, 0x20, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65,
    0x67, 0x79, 0x2e, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x04, 0x00, 0x02, 0x07, 0x01, 0x12,
    0x03, 0x34, 0x04, 0x0d, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x04, 0x00, 0x02, 0x07, 0x02, 0x12,
    0x03, 0x34, 0x10, 0x11, 0x0a, 0x43, 0x0a, 0x04, 0x04, 0x00, 0x03, 0x00, 0x12, 0x04, 0x38, 0x02,
    0x40, 0x03, 0x1a, 0x35, 0x20, 0x46, 0x69, 0x72, 0x73, 0x74, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74,
    0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x73, 0x75, 0x62,
    0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x03,
    0x00, 0x01, 0x12, 0x03, 0x38, 0x0a, 0x14, 0x0a, 0x0d, 0x0a, 0x06, 0x04, 0x00, 0x03, 0x00, 0x02,
    0x00, 0x12, 0x03, 0x39, 0x04, 0x2a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x00, 0x02, 0x00,
    0x04, 0x12, 0x03, 0x39, 0x04, 0x0c, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x00, 0x02, 0x00,
    0x06, 0x12, 0x03, 0x39, 0x0d, 0x18, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x00, 0x02, 0x00,
    0x01, 0x12, 0x03, 0x39, 0x19, 0x25, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x00, 0x02, 0x00,
    0x03, 0x12, 0x03, 0x39, 0x28, 0x29, 0x0a, 0xdd, 0x01, 0x0a, 0x06, 0x04, 0x00, 0x03, 0x00, 0x02,
    0x01, 0x12, 0x03, 0x3f, 0x04, 0x33, 0x1a, 0xcd, 0x01, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x76,
    0x61, 0x6c, 0x75, 0x65, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 0x74,
    0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x69,
    0x73, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x68, 0x65, 0x61, 0x72, 0x74, 0x62,
    0x65, 0x61, 0x74, 0x73, 0x2e, 0x20, 0x53, 0x65, 0x65, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63,
    0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x61, 0x62, 0x6f, 0x76, 0x65, 0x20, 0x6f, 0x6e, 0x20,
    0x27, 0x48, 0x45, 0x41, 0x52, 0x54, 0x42, 0x45, 0x41, 0x54, 0x27, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x6d, 0x6f, 0x72, 0x65, 0x20, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x2e, 0x0a, 0x20, 0x54,
    0x4f, 0x44, 0x4f, 0x28, 0x76, 0x69, 0x6e, 0x6f, 0x64, 0x29, 0x3a, 0x20, 0x49, 0x6d, 0x70, 0x6c,
    0x65, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x68, 0x65, 0x61, 0x72, 0x74, 0x62, 0x65, 0x61, 0x74, 0x73,
    0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x6f,
    0x6e, 0x63, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x0a, 0x20,
    0x63, 0x61, 0x6e, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20, 0x48, 0x54, 0x54, 0x50, 0x20, 0x65, 0x76,
    0x65, 0x6e, 0x74, 0x73, 0x2e, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x00, 0x02, 0x01,
    0x04, 0x12, 0x03, 0x3f, 0x04, 0x0c, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x00, 0x02, 0x01,
    0x05, 0x12, 0x03, 0x3f, 0x0d, 0x13, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x00, 0x02, 0x01,
    0x01, 0x12, 0x03, 0x3f, 0x14, 0x2e, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x00, 0x02, 0x01,
    0x03, 0x12, 0x03, 0x3f, 0x31, 0x32, 0x0a, 0xc1, 0x03, 0x0a, 0x04, 0x04, 0x00, 0x03, 0x01, 0x12,
    0x04, 0x49, 0x02, 0x4c, 0x03, 0x1a, 0xb2, 0x03, 0x20, 0x52, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65,
    0x64, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65,
    0x20, 0x61, 0x72, 0x65, 0x20, 0x6e, 0x65, 0x77, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63,
    0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6f, 0x66, 0x66, 0x65,
    0x72, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x73, 0x63, 0x68, 0x65,
    0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x6f, 0x72, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63,
    0x65, 0x73, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x62, 0x61, 0x63,
    0x6b, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64,
    0x75, 0x6c, 0x65, 0x72, 0x2e, 0x20, 0x45, 0x61, 0x63, 0x68, 0x0a, 0x20, 0x6f, 0x66, 0x66, 0x65,
    0x72, 0x20, 0x63, 0x6f, 0x72, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x64, 0x73, 0x20, 0x74, 0x6f,
    0x20, 0x61, 0x20, 0x73, 0x65, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72,
    0x63, 0x65, 0x73, 0x20, 0x6f, 0x6e, 0x20, 0x61, 0x20, 0x73, 0x6c, 0x61, 0x76, 0x65, 0x2e, 0x20,
    0x55, 0x6e, 0x74, 0x69, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64,
    0x75, 0x6c, 0x65, 0x72, 0x20, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x73, 0x20, 0x6f, 0x72, 0x20,
    0x64, 0x65, 0x63, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x6f, 0x66, 0x66, 0x65,
    0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20,
    0x61, 0x72, 0x65, 0x0a, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x72, 0x65, 0x64, 0x20,
    0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x20, 0x41, 0x63, 0x63, 0x65,
    0x70, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x6f, 0x72, 0x20, 0x44, 0x65, 0x63, 0x6c, 0x69, 0x6e, 0x69,
    0x6e, 0x67, 0x20, 0x61, 0x6e, 0x0a, 0x20, 0x69, 0x6e, 0x76, 0x65, 0x72, 0x73, 0x65, 0x20, 0x6f,
    0x66, 0x66, 0x65, 0x72, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x73, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x27, 0x73, 0x20, 0x61, 0x62,
    0x69, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x72, 0x65, 0x6c, 0x65, 0x61, 0x73,
    0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20,
    0x77, 0x69, 0x74, 0x68, 0x6f, 0x75, 0x74, 0x20, 0x76, 0x69, 0x6f, 0x6c, 0x61, 0x74, 0x69, 0x6e,
    0x67, 0x20, 0x61, 0x6e, 0x20, 0x53, 0x4c, 0x41, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00,
    0x03, 0x01, 0x01, 0x12, 0x03, 0x49, 0x0a, 0x10, 0x0a, 0x0d, 0x0a, 0x06, 0x04, 0x00, 0x03, 0x01,
    0x02, 0x00, 0x12, 0x03, 0x4a, 0x04, 0x1e, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x01, 0x02,
    0x00, 0x04, 0x12, 0x03, 0x4a, 0x04, 0x0c, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x01, 0x02,
    0x00, 0x06, 0x12, 0x03, 0x4a, 0x0d, 0x12, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x01, 0x02,
    0x00, 0x01, 0x12, 0x03, 0x4a, 0x13, 0x19, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x01, 0x02,
    0x00, 0x03, 0x12, 0x03, 0x4a, 0x1c, 0x1d, 0x0a, 0x0d, 0x0a, 0x06, 0x04, 0x00, 0x03, 0x01, 0x02,
    0x01, 0x12, 0x03, 0x4b, 0x04, 0x2d, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x01, 0x02, 0x01,
    0x04, 0x12, 0x03, 0x4b, 0x04, 0x0c, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x01, 0x02, 0x01,
    0x06, 0x12, 0x03, 0x4b, 0x0d, 0x19, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x01, 0x02, 0x01,
    0x01, 0x12, 0x03, 0x4b, 0x1a, 0x28, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x01, 0x02, 0x01,
    0x03, 0x12, 0x03, 0x4b, 0x2b, 0x2c, 0x0a, 0x8a, 0x02, 0x0a, 0x04, 0x04, 0x00, 0x03, 0x02, 0x12,
    0x04, 0x52, 0x02, 0x54, 0x03, 0x1a, 0xfb, 0x01, 0x20, 0x52, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65,
    0x64, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x61, 0x20, 0x70, 0x61, 0x72, 0x74, 0x69, 0x63, 0x75,
    0x6c, 0x61, 0x72, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x20,
    0x6c, 0x6f, 0x6e, 0x67, 0x65, 0x72, 0x20, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x28, 0x65, 0x2e,
    0x67, 0x2e, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x63,
    0x6f, 0x72, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x20, 0x68, 0x61, 0x73, 0x20, 0x62, 0x65,
    0x65, 0x6e, 0x20, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x64, 0x29, 0x20, 0x61, 0x6e, 0x64, 0x20,
    0x68, 0x65, 0x6e, 0x63, 0x65, 0x0a, 0x20, 0x6e, 0x65, 0x65, 0x64, 0x73, 0x20, 0x74, 0x6f, 0x20,
    0x62, 0x65, 0x20, 0x72, 0x65, 0x73, 0x63, 0x69, 0x6e, 0x64, 0x65, 0x64, 0x2e, 0x20, 0x41, 0x6e,
    0x79, 0x20, 0x66, 0x75, 0x74, 0x75, 0x72, 0x65, 0x20, 0x63, 0x61, 0x6c, 0x6c, 0x73, 0x20, 0x28,
    0x27, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x27, 0x20, 0x2f, 0x20, 0x27, 0x44, 0x65, 0x63, 0x6c,
    0x69, 0x6e, 0x65, 0x27, 0x29, 0x20, 0x6d, 0x61, 0x64, 0x65, 0x0a, 0x20, 0x62, 0x79, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x72, 0x65, 0x67,
    0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6f, 0x66, 0x66, 0x65,
    0x72, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69,
    0x64, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x03, 0x02, 0x01, 0x12, 0x03, 0x52, 0x0a,
    0x11, 0x0a, 0x0d, 0x0a, 0x06, 0x04, 0x00, 0x03, 0x02, 0x02, 0x00, 0x12, 0x03, 0x53, 0x04, 0x22,
    0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x02, 0x02, 0x00, 0x04, 0x12, 0x03, 0x53, 0x04, 0x0c,
    0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x02, 0x02, 0x00, 0x06, 0x12, 0x03, 0x53, 0x0d, 0x14,
    0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x02, 0x02, 0x00, 0x01, 0x12, 0x03, 0x53, 0x15, 0x1d,
    0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x02, 0x02, 0x00, 0x03, 0x12, 0x03, 0x53, 0x20, 0x21,
    0x0a, 0xd2, 0x04, 0x0a, 0x04, 0x04, 0x00, 0x03, 0x03, 0x12, 0x04, 0x5f, 0x02, 0x61, 0x03, 0x1a,
    0xc3, 0x04, 0x20, 0x52, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x20, 0x77, 0x68, 0x65, 0x6e,
    0x65, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20,
    0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68,
    0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x20,
    0x62, 0x79, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72,
    0x20, 0x6f, 0x72, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x6f, 0x72, 0x20, 0x6d, 0x61, 0x73,
    0x74, 0x65, 0x72, 0x2e, 0x20, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x75, 0x70, 0x64, 0x61,
    0x74, 0x65, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73,
    0x65, 0x64, 0x20, 0x62, 0x79, 0x0a, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x73,
    0x20, 0x74, 0x6f, 0x20, 0x72, 0x65, 0x6c, 0x69, 0x61, 0x62, 0x6c, 0x79, 0x20, 0x63, 0x6f, 0x6d,
    0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61,
    0x74, 0x75, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73,
    0x20, 0x74, 0x68, 0x61, 0x74, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 0x6d, 0x61, 0x6e, 0x61,
    0x67, 0x65, 0x2e, 0x20, 0x49, 0x74, 0x20, 0x69, 0x73, 0x20, 0x63, 0x72, 0x75, 0x63, 0x69, 0x61,
    0x6c, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x20, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61,
    0x6c, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 0x28, 0x73, 0x65, 0x65, 0x20, 0x54, 0x61,
    0x73, 0x6b, 0x53, 0x74, 0x61, 0x74, 0x65, 0x0a, 0x20, 0x69, 0x6e, 0x20, 0x76, 0x31, 0x2f, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x29, 0x20, 0x69, 0x73, 0x20, 0x73,
    0x65, 0x6e, 0x74, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75,
    0x74, 0x6f, 0x72, 0x20, 0x61, 0x73, 0x20, 0x73, 0x6f, 0x6f, 0x6e, 0x20, 0x61, 0x73, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x0a, 0x20, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61,
    0x74, 0x65, 0x73, 0x2c, 0x20, 0x69, 0x6e, 0x20, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x20, 0x66, 0x6f,
    0x72, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x72, 0x65, 0x6c, 0x65, 0x61,
    0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73,
    0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x65, 0x64, 0x0a, 0x20, 0x74, 0x6f, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x2e, 0x20, 0x49, 0x74, 0x20, 0x69, 0x73, 0x20, 0x61,
    0x6c, 0x73, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x69,
    0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x63,
    0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x65, 0x78, 0x70, 0x6c,
    0x69, 0x63, 0x69, 0x74, 0x6c, 0x79, 0x20, 0x61, 0x63, 0x6b, 0x6e, 0x6f, 0x77, 0x6c, 0x65, 0x64,
    0x67, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x70, 0x74, 0x20, 0x6f,
    0x66, 0x20, 0x61, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74,
    0x65, 0x2e, 0x20, 0x53, 0x65, 0x65, 0x0a, 0x20, 0x27, 0x41, 0x63, 0x6b, 0x6e, 0x6f, 0x77, 0x6c,
    0x65, 0x64, 0x67, 0x65, 0x27, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x27, 0x43, 0x61,
    0x6c, 0x6c, 0x27, 0x20, 0x73, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x62, 0x65, 0x6c, 0x6f,
    0x77, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x6d, 0x61, 0x6e, 0x74,
    0x69, 0x63, 0x73, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x03, 0x03, 0x01, 0x12, 0x03,
    0x5f, 0x0a, 0x10, 0x0a, 0x0d, 0x0a, 0x06, 0x04, 0x00, 0x03, 0x03, 0x02, 0x00, 0x12, 0x03, 0x60,
    0x04, 0x23, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x03, 0x02, 0x00, 0x04, 0x12, 0x03, 0x60,
    0x04, 0x0c, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x03, 0x02, 0x00, 0x06, 0x12, 0x03, 0x60,
    0x0d, 0x17, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x03, 0x02, 0x00, 0x01, 0x12, 0x03, 0x60,
    0x18, 0x1e, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x03, 0x02, 0x00, 0x03, 0x12, 0x03, 0x60,
    0x21, 0x22, 0x0a, 0xb1, 0x02, 0x0a, 0x04, 0x04, 0x00, 0x03, 0x04, 0x12, 0x04, 0x68, 0x02, 0x6c,
    0x03, 0x1a, 0xa2, 0x02, 0x20, 0x52, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x20, 0x77, 0x68,
    0x65, 0x6e, 0x20, 0x61, 0x20, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x20, 0x6d, 0x65, 0x73, 0x73,
    0x61, 0x67, 0x65, 0x20, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x69, 0x73,
    0x0a, 0x20, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x2e, 0x20, 0x4e, 0x6f, 0x74, 0x65, 0x20,
    0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
    0x65, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x0a, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x70,
    0x72, 0x65, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x20, 0x61,
    0x6e, 0x64, 0x20, 0x69, 0x73, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x66, 0x6f, 0x72, 0x77, 0x61,
    0x72, 0x64, 0x65, 0x64, 0x20, 0x28, 0x77, 0x69, 0x74, 0x68, 0x6f, 0x75, 0x74, 0x20, 0x72, 0x65,
    0x6c, 0x69, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x0a, 0x20, 0x67, 0x75, 0x61, 0x72, 0x61,
    0x6e, 0x74, 0x65, 0x65, 0x73, 0x29, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x63,
    0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x20, 0x49, 0x74, 0x20, 0x69, 0x73, 0x20, 0x75,
    0x70, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f,
    0x72, 0x20, 0x74, 0x6f, 0x20, 0x72, 0x65, 0x74, 0x72, 0x79, 0x0a, 0x20, 0x69, 0x66, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x69, 0x73, 0x20, 0x64, 0x72,
    0x6f, 0x70, 0x70, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x72, 0x65,
    0x61, 0x73, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x03, 0x04, 0x01, 0x12,
    0x03, 0x68, 0x0a, 0x11, 0x0a, 0x0d, 0x0a, 0x06, 0x04, 0x00, 0x03, 0x04, 0x02, 0x00, 0x12, 0x03,
    0x69, 0x04, 0x22, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x04, 0x02, 0x00, 0x04, 0x12, 0x03,
    0x69, 0x04, 0x0c, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x04, 0x02, 0x00, 0x06, 0x12, 0x03,
    0x69, 0x0d, 0x14, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x04, 0x02, 0x00, 0x01, 0x12, 0x03,
    0x69, 0x15, 0x1d, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x04, 0x02, 0x00, 0x03, 0x12, 0x03,
    0x69, 0x20, 0x21, 0x0a, 0x0d, 0x0a, 0x06, 0x04, 0x00, 0x03, 0x04, 0x02, 0x01, 0x12, 0x03, 0x6a,
    0x04, 0x28, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x04, 0x02, 0x01, 0x04, 0x12, 0x03, 0x6a,
    0x04, 0x0c, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x04, 0x02, 0x01, 0x06, 0x12, 0x03, 0x6a,
    0x0d, 0x17, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x04, 0x02, 0x01, 0x01, 0x12, 0x03, 0x6a,
    0x18, 0x23, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x04, 0x02, 0x01, 0x03, 0x12, 0x03, 0x6a,
    0x26, 0x27, 0x0a, 0x0d, 0x0a, 0x06, 0x04, 0x00, 0x03, 0x04, 0x02, 0x02, 0x12, 0x03, 0x6b, 0x04,
    0x1c, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x04, 0x02, 0x02, 0x04, 0x12, 0x03, 0x6b, 0x04,
    0x0c, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x04, 0x02, 0x02, 0x05, 0x12, 0x03, 0x6b, 0x0d,
    0x12, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x04, 0x02, 0x02, 0x01, 0x12, 0x03, 0x6b, 0x13,
    0x17, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x04, 0x02, 0x02, 0x03, 0x12, 0x03, 0x6b, 0x1a,
    0x1b, 0x0a, 0xe0, 0x04, 0x0a, 0x04, 0x04, 0x00, 0x03, 0x05, 0x12, 0x05, 0x78, 0x02, 0x80, 0x01,
    0x03, 0x1a, 0xd0, 0x04, 0x20, 0x52, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x20, 0x77, 0x68,
    0x65, 0x6e, 0x20, 0x61, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65,
    0x6d, 0x6f, 0x76, 0x65, 0x64, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63,
    0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x20, 0x28, 0x65, 0x2e, 0x67, 0x2e, 0x2c, 0x20, 0x66, 0x61,
    0x69, 0x6c, 0x65, 0x64, 0x0a, 0x20, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x20, 0x63, 0x68, 0x65,
    0x63, 0x6b, 0x73, 0x29, 0x20, 0x6f, 0x72, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x61, 0x6e, 0x20,
    0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x69, 0x73, 0x20, 0x74, 0x65, 0x72, 0x6d,
    0x69, 0x6e, 0x61, 0x74, 0x65, 0x64, 0x2e, 0x20, 0x4e, 0x6f, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61,
    0x74, 0x2c, 0x20, 0x74, 0x68, 0x69, 0x73, 0x0a, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x20, 0x63,
    0x6f, 0x69, 0x6e, 0x63, 0x69, 0x64, 0x65, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x72, 0x65,
    0x63, 0x65, 0x69, 0x70, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61,
    0x6c, 0x20, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x61, 0x6e, 0x79, 0x0a, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x20,
    0x74, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x6e, 0x67, 0x20,
    0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x6f, 0x72, 0x20,
    0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x72, 0x65, 0x63,
    0x65, 0x69, 0x70, 0x74, 0x20, 0x6f, 0x66, 0x0a, 0x20, 0x27, 0x52, 0x65, 0x73, 0x63, 0x69, 0x6e,
    0x64, 0x27, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x6e,
    0x79, 0x20, 0x6f, 0x75, 0x74, 0x73, 0x74, 0x61, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x6f, 0x66,
    0x66, 0x65, 0x72, 0x73, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x6e, 0x67, 0x20, 0x74,
    0x6f, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x20, 0x4e, 0x6f,
    0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x69, 0x73,
    0x20, 0x6e, 0x6f, 0x20, 0x67, 0x75, 0x61, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x65, 0x64, 0x20, 0x6f,
    0x72, 0x64, 0x65, 0x72, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x65,
    0x0a, 0x20, 0x27, 0x46, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x27, 0x2c, 0x20, 0x27, 0x55, 0x70,
    0x64, 0x61, 0x74, 0x65, 0x27, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x27, 0x52, 0x65, 0x73, 0x63, 0x69,
    0x6e, 0x64, 0x27, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20,
    0x61, 0x6e, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x6f, 0x72, 0x20, 0x65, 0x78, 0x65, 0x63,
    0x75, 0x74, 0x6f, 0x72, 0x0a, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x64,
    0x2e, 0x0a, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x28, 0x76, 0x69, 0x6e, 0x6f, 0x64, 0x29, 0x3a, 0x20,
    0x43, 0x6f, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x72, 0x20, 0x73, 0x70, 0x6c, 0x69, 0x74, 0x74, 0x69,
    0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x6f, 0x73, 0x74, 0x20, 0x61, 0x67, 0x65, 0x6e,
    0x74, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x65, 0x64,
    0x0a, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x69, 0x6e, 0x74, 0x6f, 0x20,
    0x73, 0x65, 0x70, 0x61, 0x72, 0x61, 0x74, 0x65, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x20,
    0x61, 0x6e, 0x64, 0x20, 0x65, 0x6e, 0x73, 0x75, 0x72, 0x65, 0x20, 0x69, 0x74, 0x27, 0x73, 0x20,
    0x72, 0x65, 0x6c, 0x69, 0x61, 0x62, 0x6c, 0x79, 0x20, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74,
    0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x03, 0x05, 0x01, 0x12, 0x03, 0x78,
    0x0a, 0x11, 0x0a, 0x0d, 0x0a, 0x06, 0x04, 0x00, 0x03, 0x05, 0x02, 0x00, 0x12, 0x03, 0x79, 0x04,
    0x22, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x05, 0x02, 0x00, 0x04, 0x12, 0x03, 0x79, 0x04,
    0x0c, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x05, 0x02, 0x00, 0x06, 0x12, 0x03, 0x79, 0x0d,
    0x14, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x05, 0x02, 0x00, 0x01, 0x12, 0x03, 0x79, 0x15,
    0x1d, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x05, 0x02, 0x00, 0x03, 0x12, 0x03, 0x79, 0x20,
    0x21, 0x0a, 0xae, 0x01, 0x0a, 0x06, 0x04, 0x00, 0x03, 0x05, 0x02, 0x01, 0x12, 0x03, 0x7e, 0x04,
    0x28, 0x1a, 0x9e, 0x01, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x77, 0x61, 0x73,
    0x20, 0x6a, 0x75, 0x73, 0x74, 0x20, 0x61, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x20,
    0x6f, 0x66, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x6f,
    0x6e, 0x20, 0x61, 0x6e, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a,
    0x20, 0x27, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x5f, 0x69, 0x64, 0x27, 0x20, 0x77,
    0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 0x74, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x70,
    0x6f, 0x73, 0x73, 0x69, 0x62, 0x6c, 0x79, 0x20, 0x27, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x27,
    0x20, 0x28, 0x69, 0x66, 0x20, 0x77, 0x65, 0x20, 0x77, 0x65, 0x72, 0x65, 0x0a, 0x20, 0x61, 0x62,
    0x6c, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x65, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x69, 0x74, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x29,
    0x2e, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x05, 0x02, 0x01, 0x04, 0x12, 0x03, 0x7e,
    0x04, 0x0c, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x05, 0x02, 0x01, 0x06, 0x12, 0x03, 0x7e,
    0x0d, 0x17, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x05, 0x02, 0x01, 0x01, 0x12, 0x03, 0x7e,
    0x18, 0x23, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x05, 0x02, 0x01, 0x03, 0x12, 0x03, 0x7e,
    0x26, 0x27, 0x0a, 0x0d, 0x0a, 0x06, 0x04, 0x00, 0x03, 0x05, 0x02, 0x02, 0x12, 0x03, 0x7f, 0x04,
    0x1e, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x05, 0x02, 0x02, 0x04, 0x12, 0x03, 0x7f, 0x04,
    0x0c, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x05, 0x02, 0x02, 0x05, 0x12, 0x03, 0x7f, 0x0d,
    0x12, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x05, 0x02, 0x02, 0x01, 0x12, 0x03, 0x7f, 0x13,
    0x19, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x00, 0x03, 0x05, 0x02, 0x02, 0x03, 0x12, 0x03, 0x7f, 0x1c,
    0x1d, 0x0a, 0xf8, 0x02, 0x0a, 0x04, 0x04, 0x00, 0x03, 0x06, 0x12, 0x06, 0x89, 0x01, 0x02, 0x8b,
    0x01, 0x03, 0x1a, 0xe7, 0x02, 0x20, 0x52, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x20, 0x77,
    0x68, 0x65, 0x6e, 0x20, 0x61, 0x6e, 0x20, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x66,
    0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x28, 0x65, 0x2e, 0x67, 0x2e, 0x2c, 0x20,
    0x75, 0x6e, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x64, 0x2c,
    0x0a, 0x20, 0x75, 0x6e, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x65, 0x64, 0x29, 0x20,
    0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x75, 0x62, 0x73,
    0x63, 0x72, 0x69, 0x62, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d,
    0x61, 0x73, 0x74, 0x65, 0x72, 0x2e, 0x20, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x20, 0x63, 0x61, 0x6e,
    0x0a, 0x20, 0x61, 0x6c, 0x73, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76,
    0x65, 0x64, 0x20, 0x69, 0x66, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20,
    0x73, 0x65, 0x6e, 0x64, 0x73, 0x20, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x43, 0x61,
    0x6c, 0x6c, 0x73, 0x20, 0x28, 0x65, 0x2e, 0x67, 0x2e, 0x2c, 0x20, 0x6e, 0x6f, 0x74, 0x0a, 0x20,
    0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x6c, 0x79, 0x20, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c,
    0x69, 0x7a, 0x65, 0x64, 0x29, 0x2e, 0x0a, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x28, 0x76, 0x69, 0x6e,
    0x6f, 0x64, 0x29, 0x3a, 0x20, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73,
    0x20, 0x6f, 0x6e, 0x63, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6f, 0x6c, 0x64, 0x20, 0x73, 0x63,
    0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x69,
    0x73, 0x20, 0x6e, 0x6f, 0x0a, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x65, 0x72, 0x20, 0x73, 0x75, 0x70,
    0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x2e, 0x20, 0x57, 0x69, 0x74, 0x68, 0x20, 0x48, 0x54, 0x54,
    0x50, 0x20, 0x41, 0x50, 0x49, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73,
    0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x65,
    0x64, 0x20, 0x76, 0x69, 0x61, 0x0a, 0x20, 0x48, 0x54, 0x54, 0x50, 0x20, 0x72, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x20, 0x63, 0x6f, 0x64, 0x65, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x00, 0x03, 0x06, 0x01, 0x12, 0x04, 0x89, 0x01, 0x0a, 0x0f, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x00, 0x03, 0x06, 0x02, 0x00, 0x12, 0x04, 0x8a, 0x01, 0x04, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x00, 0x03, 0x06, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8a, 0x01, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x00, 0x03, 0x06, 0x02, 0x00, 0x05, 0x12, 0x04, 0x8a, 0x01, 0x0d, 0x13, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x00, 0x03, 0x06, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8a, 0x01, 0x14, 0x1b, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x00, 0x03, 0x06, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8a, 0x01, 0x1e, 0x1f, 0x0a,
    0x88, 0x01, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0x8f, 0x01, 0x02, 0x19, 0x1a, 0x7a,
    0x20, 0x54, 0x79, 0x70, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x76, 0x65,
    0x6e, 0x74, 0x2c, 0x20, 0x69, 0x6e, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x73, 0x20, 0x77, 0x68,
    0x69, 0x63, 0x68, 0x20, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x20, 0x66, 0x69, 0x65,
    0x6c, 0x64, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x77, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20,
    0x62, 0x65, 0x0a, 0x20, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x69, 0x66, 0x20, 0x74,
    0x68, 0x61, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x68, 0x61, 0x73, 0x20, 0x61, 0x20, 0x6e,
    0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x64, 0x65,
    0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00,
    0x02, 0x00, 0x04, 0x12, 0x04, 0x8f, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x00, 0x06, 0x12, 0x04, 0x8f, 0x01, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00,
    0x01, 0x12, 0x04, 0x8f, 0x01, 0x10, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x03,
    0x12, 0x04, 0x8f, 0x01, 0x17, 0x18, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04,
    0x91, 0x01, 0x02, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0x91,
    0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x06, 0x12, 0x04, 0x91, 0x01,
    0x0b, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0x91, 0x01, 0x16,
    0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0x91, 0x01, 0x23, 0x24,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x02, 0x12, 0x04, 0x92, 0x01, 0x02, 0x1d, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0x92, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x00, 0x02, 0x02, 0x06, 0x12, 0x04, 0x92, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0x92, 0x01, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0x92, 0x01, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x00,
    0x02, 0x03, 0x12, 0x04, 0x93, 0x01, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x03,
    0x04, 0x12, 0x04, 0x93, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x03, 0x06,
    0x12, 0x04, 0x93, 0x01, 0x0b, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x03, 0x01, 0x12,
    0x04, 0x93, 0x01, 0x13, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04,
    0x93, 0x01, 0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x04, 0x12, 0x04, 0x94, 0x01,
    0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x04, 0x04, 0x12, 0x04, 0x94, 0x01, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x04, 0x06, 0x12, 0x04, 0x94, 0x01, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x04, 0x01, 0x12, 0x04, 0x94, 0x01, 0x12, 0x18, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x04, 0x03, 0x12, 0x04, 0x94, 0x01, 0x1b, 0x1c, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x00, 0x02, 0x05, 0x12, 0x04, 0x95, 0x01, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x00, 0x02, 0x05, 0x04, 0x12, 0x04, 0x95, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x00, 0x02, 0x05, 0x06, 0x12, 0x04, 0x95, 0x01, 0x0b, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00,
    0x02, 0x05, 0x01, 0x12, 0x04, 0x95, 0x01, 0x13, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x05, 0x03, 0x12, 0x04, 0x95, 0x01, 0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x06,
    0x12, 0x04, 0x96, 0x01, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x06, 0x04, 0x12,
    0x04, 0x96, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x06, 0x06, 0x12, 0x04,
    0x96, 0x01, 0x0b, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x06, 0x01, 0x12, 0x04, 0x96,
    0x01, 0x13, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x06, 0x03, 0x12, 0x04, 0x96, 0x01,
    0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x07, 0x12, 0x04, 0x97, 0x01, 0x02, 0x1b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x07, 0x04, 0x12, 0x04, 0x97, 0x01, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x07, 0x06, 0x12, 0x04, 0x97, 0x01, 0x0b, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x00, 0x02, 0x07, 0x01, 0x12, 0x04, 0x97, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x00, 0x02, 0x07, 0x03, 0x12, 0x04, 0x97, 0x01, 0x19, 0x1a, 0x0a, 0x86, 0x01, 0x0a,
    0x02, 0x04, 0x01, 0x12, 0x06, 0xa1, 0x01, 0x00, 0xd2, 0x02, 0x01, 0x1a, 0x78, 0x2a, 0x0a, 0x20,
    0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x63, 0x61, 0x6c, 0x6c, 0x20, 0x41,
    0x50, 0x49, 0x2e, 0x0a, 0x0a, 0x20, 0x4c, 0x69, 0x6b, 0x65, 0x20, 0x45, 0x76, 0x65, 0x6e, 0x74,
    0x2c, 0x20, 0x61, 0x20, 0x43, 0x61, 0x6c, 0x6c, 0x20, 0x69, 0x73, 0x20, 0x64, 0x65, 0x73, 0x63,
    0x72, 0x69, 0x62, 0x65, 0x64, 0x20, 0x75, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x73, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f,
    0x6c, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x0a, 0x20, 0x22, 0x75, 0x6e, 0x69, 0x6f, 0x6e,
    0x22, 0x20, 0x74, 0x72, 0x69, 0x63, 0x6b, 0x20, 0x28, 0x73, 0x65, 0x65, 0x20, 0x61, 0x62, 0x6f,
    0x76, 0x65, 0x29, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x01, 0x01, 0x12, 0x04, 0xa1, 0x01,
    0x08, 0x0c, 0x0a, 0x56, 0x0a, 0x04, 0x04, 0x01, 0x04, 0x00, 0x12, 0x06, 0xa4, 0x01, 0x02, 0xb9,
    0x01, 0x03, 0x1a, 0x46, 0x20, 0x50, 0x6f, 0x73, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x20, 0x63, 0x61,
    0x6c, 0x6c, 0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2c, 0x20, 0x66, 0x6f, 0x6c, 0x6c, 0x6f, 0x77,
    0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x64, 0x65,
    0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x69, 0x66, 0x0a, 0x20, 0x61, 0x70,
    0x70, 0x6c, 0x69, 0x63, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01,
    0x04, 0x00, 0x01, 0x12, 0x04, 0xa4, 0x01, 0x07, 0x0b, 0x0a, 0x28, 0x0a, 0x06, 0x04, 0x01, 0x04,
    0x00, 0x02, 0x00, 0x12, 0x04, 0xa5, 0x01, 0x04, 0x12, 0x22, 0x18, 0x20, 0x53, 0x65, 0x65, 0x20,
    0x27, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x27, 0x20, 0x62, 0x65, 0x6c, 0x6f,
    0x77, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xa5, 0x01, 0x04, 0x0d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12,
    0x04, 0xa5, 0x01, 0x10, 0x11, 0x0a, 0x47, 0x0a, 0x06, 0x04, 0x01, 0x04, 0x00, 0x02, 0x01, 0x12,
    0x04, 0xa6, 0x01, 0x04, 0x11, 0x22, 0x37, 0x20, 0x53, 0x68, 0x75, 0x74, 0x73, 0x20, 0x64, 0x6f,
    0x77, 0x6e, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x2f, 0x65, 0x78, 0x65,
    0x63, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x72, 0x65, 0x6d, 0x6f, 0x76,
    0x65, 0x73, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x0a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa6, 0x01, 0x04, 0x0c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xa6, 0x01, 0x0f, 0x10,
    0x0a, 0x25, 0x0a, 0x06, 0x04, 0x01, 0x04, 0x00, 0x02, 0x02, 0x12, 0x04, 0xa7, 0x01, 0x04, 0x0f,
    0x22, 0x15, 0x20, 0x53, 0x65, 0x65, 0x20, 0x27, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x27, 0x20,
    0x62, 0x65, 0x6c, 0x6f, 0x77, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02,
    0x02, 0x01, 0x12, 0x04, 0xa7, 0x01, 0x04, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00,
    0x02, 0x02, 0x02, 0x12, 0x04, 0xa7, 0x01, 0x0d, 0x0e, 0x0a, 0x26, 0x0a, 0x06, 0x04, 0x01, 0x04,
    0x00, 0x02, 0x03, 0x12, 0x04, 0xa8, 0x01, 0x04, 0x10, 0x22, 0x16, 0x20, 0x53, 0x65, 0x65, 0x20,
    0x27, 0x44, 0x65, 0x63, 0x6c, 0x69, 0x6e, 0x65, 0x27, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x77, 0x2e,
    0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xa8, 0x01,
    0x04, 0x0b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x03, 0x02, 0x12, 0x04, 0xa8,
    0x01, 0x0e, 0x0f, 0x0a, 0x49, 0x0a, 0x06, 0x04, 0x01, 0x04, 0x00, 0x02, 0x04, 0x12, 0x04, 0xa9,
    0x01, 0x04, 0x0f, 0x22, 0x39, 0x20, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x73, 0x20, 0x61, 0x6e,
    0x79, 0x20, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x20, 0x66, 0x69, 0x6c, 0x74, 0x65,
    0x72, 0x73, 0x20, 0x73, 0x65, 0x74, 0x20, 0x76, 0x69, 0x61, 0x20, 0x41, 0x43, 0x43, 0x45, 0x50,
    0x54, 0x20, 0x6f, 0x72, 0x20, 0x44, 0x45, 0x43, 0x4c, 0x49, 0x4e, 0x45, 0x2e, 0x0a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x04, 0x01, 0x12, 0x04, 0xa9, 0x01, 0x04, 0x0a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x04, 0x02, 0x12, 0x04, 0xa9, 0x01, 0x0d, 0x0e,
    0x0a, 0x23, 0x0a, 0x06, 0x04, 0x01, 0x04, 0x00, 0x02, 0x05, 0x12, 0x04, 0xaa, 0x01, 0x04, 0x0d,
    0x22, 0x13, 0x20, 0x53, 0x65, 0x65, 0x20, 0x27, 0x4b, 0x69, 0x6c, 0x6c, 0x27, 0x20, 0x62, 0x65,
    0x6c, 0x6f, 0x77, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x05, 0x01,
    0x12, 0x04, 0xaa, 0x01, 0x04, 0x08, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x05,
    0x02, 0x12, 0x04, 0xaa, 0x01, 0x0b, 0x0c, 0x0a, 0x27, 0x0a, 0x06, 0x04, 0x01, 0x04, 0x00, 0x02,
    0x06, 0x12, 0x04, 0xab, 0x01, 0x04, 0x11, 0x22, 0x17, 0x20, 0x53, 0x65, 0x65, 0x20, 0x27, 0x53,
    0x68, 0x75, 0x74, 0x64, 0x6f, 0x77, 0x6e, 0x27, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x77, 0x2e, 0x0a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x06, 0x01, 0x12, 0x04, 0xab, 0x01, 0x04,
    0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x06, 0x02, 0x12, 0x04, 0xab, 0x01,
    0x0f, 0x10, 0x0a, 0x2a, 0x0a, 0x06, 0x04, 0x01, 0x04, 0x00, 0x02, 0x07, 0x12, 0x04, 0xac, 0x01,
    0x04, 0x14, 0x22, 0x1a, 0x20, 0x53, 0x65, 0x65, 0x20, 0x27, 0x41, 0x63, 0x6b, 0x6e, 0x6f, 0x77,
    0x6c, 0x65, 0x64, 0x67, 0x65, 0x27, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x77, 0x2e, 0x0a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x07, 0x01, 0x12, 0x04, 0xac, 0x01, 0x04, 0x0f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x07, 0x02, 0x12, 0x04, 0xac, 0x01, 0x12, 0x13,
    0x0a, 0x28, 0x0a, 0x06, 0x04, 0x01, 0x04, 0x00, 0x02, 0x08, 0x12, 0x04, 0xad, 0x01, 0x04, 0x12,
    0x22, 0x18, 0x20, 0x53, 0x65, 0x65, 0x20, 0x27, 0x52, 0x65, 0x63, 0x6f, 0x6e, 0x63, 0x69, 0x6c,
    0x65, 0x27, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x77, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01,
    0x04, 0x00, 0x02, 0x08, 0x01, 0x12, 0x04, 0xad, 0x01, 0x04, 0x0d, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x01, 0x04, 0x00, 0x02, 0x08, 0x02, 0x12, 0x04, 0xad, 0x01, 0x10, 0x11, 0x0a, 0x26, 0x0a, 0x06,
    0x04, 0x01, 0x04, 0x00, 0x02, 0x09, 0x12, 0x04, 0xae, 0x01, 0x04, 0x11, 0x22, 0x16, 0x20, 0x53,
    0x65, 0x65, 0x20, 0x27, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x27, 0x20, 0x62, 0x65, 0x6c,
    0x6f, 0x77, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x09, 0x01, 0x12,
    0x04, 0xae, 0x01, 0x04, 0x0b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x09, 0x02,
    0x12, 0x04, 0xae, 0x01, 0x0e, 0x10, 0x0a, 0x26, 0x0a, 0x06, 0x04, 0x01, 0x04, 0x00, 0x02, 0x0a,
    0x12, 0x04, 0xaf, 0x01, 0x04, 0x11, 0x22, 0x16, 0x20, 0x53, 0x65, 0x65, 0x20, 0x27, 0x52, 0x65,
    0x71, 0x75, 0x65, 0x73, 0x74, 0x27, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x77, 0x2e, 0x0a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xaf, 0x01, 0x04, 0x0b, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x0a, 0x02, 0x12, 0x04, 0xaf, 0x01, 0x0e, 0x10,
    0x0a, 0x48, 0x0a, 0x06, 0x04, 0x01, 0x04, 0x00, 0x02, 0x0b, 0x12, 0x04, 0xb0, 0x01, 0x04, 0x12,
    0x22, 0x38, 0x20, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72,
    0x20, 0x74, 0x6f, 0x20, 0x73, 0x74, 0x6f, 0x70, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67,
    0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66,
    0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01,
    0x04, 0x00, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xb0, 0x01, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x01, 0x04, 0x00, 0x02, 0x0b, 0x02, 0x12, 0x04, 0xb0, 0x01, 0x0f, 0x11, 0x0a, 0xa2, 0x01, 0x0a,
    0x04, 0x04, 0x01, 0x03, 0x00, 0x12, 0x06, 0xbe, 0x01, 0x02, 0xd1, 0x01, 0x03, 0x1a, 0x91, 0x01,
    0x20, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x72, 0x65, 0x63,
    0x65, 0x69, 0x76, 0x65, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x20, 0x41, 0x0a, 0x20,
    0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x73,
    0x65, 0x6e, 0x64, 0x20, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x20, 0x63, 0x61, 0x6c, 0x6c, 0x73, 0x20,
    0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x69, 0x74, 0x20, 0x68, 0x61,
    0x73, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20,
    0x53, 0x55, 0x42, 0x43, 0x52, 0x49, 0x42, 0x45, 0x44, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x03, 0x00, 0x01, 0x12, 0x04, 0xbe, 0x01, 0x0a, 0x13,
    0x0a, 0x65, 0x0a, 0x06, 0x04, 0x01, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xc1, 0x01, 0x04, 0x2e,
    0x1a, 0x55, 0x20, 0x53, 0x65, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x65,
    0x6e, 0x74, 0x73, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x77, 0x20, 0x6f, 0x6e, 0x20, 0x27, 0x66, 0x72,
    0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x5f, 0x69, 0x64, 0x27, 0x20, 0x6f, 0x6e, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x73, 0x65, 0x6d, 0x61, 0x6e, 0x74, 0x69, 0x63, 0x73, 0x20, 0x66, 0x6f, 0x72,
    0x0a, 0x20, 0x27, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x5f, 0x69, 0x6e, 0x66,
    0x6f, 0x2e, 0x69, 0x64, 0x27, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xc1, 0x01, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00,
    0x02, 0x00, 0x06, 0x12, 0x04, 0xc1, 0x01, 0x0d, 0x1a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03,
    0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc1, 0x01, 0x1b, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01,
    0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc1, 0x01, 0x2c, 0x2d, 0x0a, 0xe9, 0x05, 0x0a, 0x06,
    0x04, 0x01, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xd0, 0x01, 0x04, 0x1c, 0x1a, 0xd8, 0x05, 0x20,
    0x27, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x27, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x69, 0x73,
    0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x72, 0x65, 0x6c, 0x65, 0x76, 0x61, 0x6e, 0x74, 0x20, 0x77,
    0x68, 0x65, 0x6e, 0x20, 0x27, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x5f, 0x69,
    0x6e, 0x66, 0x6f, 0x2e, 0x69, 0x64, 0x27, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 0x2e, 0x0a,
    0x20, 0x49, 0x74, 0x20, 0x74, 0x65, 0x6c, 0x6c, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61,
    0x73, 0x74, 0x65, 0x72, 0x20, 0x77, 0x68, 0x61, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x6f, 0x20,
    0x69, 0x6e, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x61, 0x6e, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61,
    0x6e, 0x63, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x73, 0x63, 0x68, 0x65,
    0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x73, 0x20, 0x74,
    0x6f, 0x20, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x20, 0x77, 0x68, 0x65, 0x6e,
    0x20, 0x61, 0x6e, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63,
    0x65, 0x20, 0x6f, 0x66, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x0a, 0x20, 0x61, 0x6c, 0x72, 0x65,
    0x61, 0x64, 0x79, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x28, 0x65,
    0x2e, 0x67, 0x2e, 0x2c, 0x20, 0x73, 0x70, 0x6c, 0x69, 0x74, 0x20, 0x62, 0x72, 0x61, 0x69, 0x6e,
    0x20, 0x64, 0x75, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20,
    0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x29, 0x2e, 0x0a, 0x20, 0x49, 0x66, 0x20,
    0x27, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x27, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x2c,
    0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20,
    0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6c, 0x6c, 0x6f,
    0x77, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x6f, 0x6c, 0x64,
    0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64,
    0x75, 0x6c, 0x65, 0x72, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x20, 0x69, 0x73,
    0x20, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64, 0x2e, 0x20, 0x49,
    0x66, 0x20, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x2c, 0x0a, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x73,
    0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63,
    0x65, 0x20, 0x69, 0x73, 0x20, 0x64, 0x69, 0x73, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x20,
    0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x6e, 0x20,
    0x66, 0x61, 0x76, 0x6f, 0x72, 0x20, 0x6f, 0x66, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x6c,
    0x72, 0x65, 0x61, 0x64, 0x79, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20,
    0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e,
    0x63, 0x65, 0x2e, 0x0a, 0x0a, 0x20, 0x49, 0x74, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x63, 0x6f,
    0x6d, 0x6d, 0x65, 0x6e, 0x64, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x65, 0x74, 0x20, 0x74,
    0x68, 0x69, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x6f, 0x6e, 0x6c, 0x79,
    0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x61, 0x20, 0x6e, 0x65, 0x77, 0x6c, 0x79, 0x20, 0x65, 0x6c,
    0x65, 0x63, 0x74, 0x65, 0x64, 0x0a, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72,
    0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x74, 0x74,
    0x65, 0x6d, 0x70, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x75, 0x62, 0x73, 0x63,
    0x72, 0x69, 0x62, 0x65, 0x20, 0x62, 0x75, 0x74, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x77, 0x68, 0x65,
    0x6e, 0x20, 0x61, 0x0a, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x69,
    0x73, 0x20, 0x72, 0x65, 0x74, 0x72, 0x79, 0x69, 0x6e, 0x67, 0x20, 0x73, 0x75, 0x62, 0x73, 0x63,
    0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28, 0x65, 0x2e, 0x67, 0x2e, 0x2c, 0x20, 0x64,
    0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x72, 0x0a,
    0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x6f, 0x76, 0x65, 0x72,
    0x3b, 0x20, 0x73, 0x65, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x2f, 0x73, 0x63, 0x68, 0x65,
    0x64, 0x2e, 0x63, 0x70, 0x70, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x78, 0x61,
    0x6d, 0x70, 0x6c, 0x65, 0x29, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xd0, 0x01, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00,
    0x02, 0x01, 0x05, 0x12, 0x04, 0xd0, 0x01, 0x0d, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03,
    0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd0, 0x01, 0x12, 0x17, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01,
    0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd0, 0x01, 0x1a, 0x1b, 0x0a, 0xdd, 0x05, 0x0a, 0x04,
    0x04, 0x01, 0x03, 0x01, 0x12, 0x06, 0xe8, 0x01, 0x02, 0xec, 0x01, 0x03, 0x1a, 0xcc, 0x05, 0x20,
    0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72,
    0x2c, 0x20, 0x70, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x73, 0x0a, 0x20, 0x69, 0x6e, 0x20, 0x61, 0x20, 0x73, 0x65, 0x71, 0x75,
    0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x20, 0x6d, 0x61, 0x6e, 0x6e, 0x65, 0x72, 0x2e, 0x0a, 0x0a,
    0x20, 0x45, 0x2e, 0x67, 0x2e, 0x20, 0x4c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x20, 0x61, 0x20, 0x74,
    0x61, 0x73, 0x6b, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x6e, 0x65, 0x77, 0x6c, 0x79,
    0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x20, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73,
    0x74, 0x65, 0x6e, 0x74, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x3a, 0x0a, 0x0a, 0x20, 0x20,
    0x20, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x20, 0x7b, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6f,
    0x66, 0x66, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x73, 0x3a, 0x20, 0x5b, 0x20, 0x2e, 0x2e, 0x2e, 0x20,
    0x5d, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x73, 0x3a, 0x20, 0x5b, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7b, 0x20, 0x74, 0x79,
    0x70, 0x65, 0x3a, 0x20, 0x52, 0x45, 0x53, 0x45, 0x52, 0x56, 0x45, 0x2c, 0x0a, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x3a, 0x20, 0x7b,
    0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x3a, 0x20, 0x5b, 0x20, 0x64, 0x69,
    0x73, 0x6b, 0x28, 0x72, 0x6f, 0x6c, 0x65, 0x29, 0x3a, 0x32, 0x20, 0x5d, 0x20, 0x7d, 0x20, 0x7d,
    0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7b, 0x20, 0x74, 0x79, 0x70, 0x65, 0x3a, 0x20,
    0x43, 0x52, 0x45, 0x41, 0x54, 0x45, 0x2c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x3a, 0x20, 0x7b, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x6d,
    0x65, 0x73, 0x3a, 0x20, 0x5b, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x28, 0x72, 0x6f, 0x6c, 0x65, 0x29,
    0x3a, 0x31, 0x2b, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x20, 0x5d,
    0x20, 0x7d, 0x20, 0x7d, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7b, 0x20, 0x74, 0x79,
    0x70, 0x65, 0x3a, 0x20, 0x4c, 0x41, 0x55, 0x4e, 0x43, 0x48, 0x2c, 0x0a, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x3a, 0x20, 0x7b, 0x20, 0x74,
    0x61, 0x73, 0x6b, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x73, 0x20, 0x2e, 0x2e, 0x2e, 0x20, 0x64, 0x69,
    0x73, 0x6b, 0x28, 0x72, 0x6f, 0x6c, 0x65, 0x29, 0x3a, 0x31, 0x3b, 0x64, 0x69, 0x73, 0x6b, 0x28,
    0x72, 0x6f, 0x6c, 0x65, 0x29, 0x3a, 0x31, 0x2b, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65,
    0x6e, 0x63, 0x65, 0x20, 0x7d, 0x20, 0x7d, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5d, 0x0a, 0x20,
    0x20, 0x20, 0x7d, 0x0a, 0x0a, 0x20, 0x4e, 0x6f, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20,
    0x61, 0x6e, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72,
    0xe2, 0x80, 0x99, 0x73, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x6e,
    0x6f, 0x74, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x27,
    0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x27, 0x0a, 0x20, 0x63, 0x61, 0x6c, 0x6c, 0x20, 0x28, 0x65,
    0x2e, 0x67, 0x2e, 0x2c, 0x20, 0x74, 0x6f, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x20, 0x61,
    0x20, 0x74, 0x61, 0x73, 0x6b, 0x29, 0x20, 0x61, 0x72, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69,
    0x64, 0x65, 0x72, 0x65, 0x64, 0x20, 0x75, 0x6e, 0x75, 0x73, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x64,
    0x20, 0x6d, 0x69, 0x67, 0x68, 0x74, 0x20, 0x62, 0x65, 0x0a, 0x20, 0x72, 0x65, 0x6f, 0x66, 0x66,
    0x65, 0x72, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x20, 0x66, 0x72,
    0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x2e, 0x20, 0x49, 0x6e, 0x20, 0x6f, 0x74, 0x68,
    0x65, 0x72, 0x20, 0x77, 0x6f, 0x72, 0x64, 0x73, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61,
    0x6d, 0x65, 0x20, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x49, 0x44, 0x0a, 0x20, 0x63, 0x61, 0x6e, 0x6e,
    0x6f, 0x74, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x6d, 0x6f,
    0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x27, 0x41, 0x63, 0x63,
    0x65, 0x70, 0x74, 0x27, 0x20, 0x63, 0x61, 0x6c, 0x6c, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x01, 0x03, 0x01, 0x01, 0x12, 0x04, 0xe8, 0x01, 0x0a, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x01,
    0x03, 0x01, 0x02, 0x00, 0x12, 0x04, 0xe9, 0x01, 0x04, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01,
    0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe9, 0x01, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x01, 0x03, 0x01, 0x02, 0x00, 0x06, 0x12, 0x04, 0xe9, 0x01, 0x0d, 0x14, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x01, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe9, 0x01, 0x15, 0x1e, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x01, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe9, 0x01, 0x21, 0x22, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x01, 0x03, 0x01, 0x02, 0x01, 0x12, 0x04, 0xea, 0x01, 0x04, 0x2c, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x01, 0x03, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xea, 0x01, 0x04, 0x0c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x01, 0x02, 0x01, 0x06, 0x12, 0x04, 0xea, 0x01, 0x0d, 0x1c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xea, 0x01, 0x1d,
    0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xea, 0x01,
    0x2a, 0x2b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x01, 0x03, 0x01, 0x02, 0x02, 0x12, 0x04, 0xeb, 0x01,
    0x04, 0x21, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x01, 0x02, 0x02, 0x04, 0x12, 0x04, 0xeb,
    0x01, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x01, 0x02, 0x02, 0x06, 0x12, 0x04,
    0xeb, 0x01, 0x0d, 0x14, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x01, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xeb, 0x01, 0x15, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x01, 0x02, 0x02, 0x03,
    0x12, 0x04, 0xeb, 0x01, 0x1f, 0x20, 0x0a, 0xf0, 0x01, 0x0a, 0x04, 0x04, 0x01, 0x03, 0x02, 0x12,
    0x06, 0xf2, 0x01, 0x02, 0xf5, 0x01, 0x03, 0x1a, 0xdf, 0x01, 0x20, 0x44, 0x65, 0x63, 0x6c, 0x69,
    0x6e, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x2c, 0x20, 0x73, 0x69,
    0x67, 0x6e, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x73, 0x74,
    0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x70, 0x6f, 0x74, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x6c,
    0x79, 0x20, 0x72, 0x65, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72,
    0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20, 0x64, 0x69,
    0x66, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72,
    0x6b, 0x2e, 0x20, 0x4e, 0x6f, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x69,
    0x73, 0x20, 0x69, 0x73, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x0a, 0x20, 0x61, 0x73, 0x20, 0x73, 0x65,
    0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x20, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x20,
    0x63, 0x61, 0x6c, 0x6c, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x6e, 0x6f, 0x20, 0x6f, 0x70, 0x65,
    0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x20, 0x53, 0x65, 0x65, 0x20, 0x63, 0x6f, 0x6d,
    0x6d, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x6f, 0x6e, 0x0a, 0x20, 0x74, 0x6f, 0x70, 0x20, 0x6f, 0x66,
    0x20, 0x27, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x27, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x73, 0x65,
    0x6d, 0x61, 0x6e, 0x74, 0x69, 0x63, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x03,
    0x02, 0x01, 0x12, 0x04, 0xf2, 0x01, 0x0a, 0x11, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x01, 0x03, 0x02,
    0x02, 0x00, 0x12, 0x04, 0xf3, 0x01, 0x04, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x02,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xf3, 0x01, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03,
    0x02, 0x02, 0x00, 0x06, 0x12, 0x04, 0xf3, 0x01, 0x0d, 0x14, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01,
    0x03, 0x02, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf3, 0x01, 0x15, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x01, 0x03, 0x02, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf3, 0x01, 0x21, 0x22, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x01, 0x03, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf4, 0x01, 0x04, 0x21, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x01, 0x03, 0x02, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf4, 0x01, 0x04, 0x0c, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x01, 0x03, 0x02, 0x02, 0x01, 0x06, 0x12, 0x04, 0xf4, 0x01, 0x0d, 0x14, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x01, 0x03, 0x02, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf4, 0x01, 0x15, 0x1c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x02, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf4, 0x01, 0x1f, 0x20,
    0x0a, 0xa1, 0x03, 0x0a, 0x04, 0x04, 0x01, 0x03, 0x03, 0x12, 0x06, 0xfe, 0x01, 0x02, 0x81, 0x02,
    0x03, 0x1a, 0x90, 0x03, 0x20, 0x4b, 0x69, 0x6c, 0x6c, 0x73, 0x20, 0x61, 0x20, 0x73, 0x70, 0x65,
    0x63, 0x69, 0x66, 0x69, 0x63, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x68, 0x61, 0x73,
    0x20, 0x61, 0x20, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74,
    0x6f, 0x72, 0x2c, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6b, 0x69, 0x6c, 0x6c, 0x20, 0x69, 0x73,
    0x20, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x69,
    0x74, 0x20, 0x69, 0x73, 0x20, 0x75, 0x70, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20,
    0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x6b, 0x69, 0x6c, 0x6c,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x73, 0x65,
    0x6e, 0x64, 0x20, 0x61, 0x20, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x4b, 0x49, 0x4c, 0x4c, 0x45, 0x44,
    0x20, 0x28, 0x6f, 0x72, 0x20, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x45, 0x44,
    0x29, 0x0a, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x20, 0x4e, 0x6f, 0x74, 0x65, 0x20,
    0x74, 0x68, 0x61, 0x74, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x20, 0x72, 0x65, 0x6c, 0x65, 0x61,
    0x73, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
    0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x6f, 0x6e, 0x63,
    0x65, 0x20, 0x69, 0x74, 0x0a, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x73, 0x20, 0x61,
    0x20, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x6c, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65,
    0x20, 0x28, 0x53, 0x65, 0x65, 0x20, 0x54, 0x61, 0x73, 0x6b, 0x53, 0x74, 0x61, 0x74, 0x65, 0x20,
    0x69, 0x6e, 0x20, 0x76, 0x31, 0x2f, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74,
    0x6f, 0x29, 0x20, 0x66, 0x6f, 0x72, 0x0a, 0x20, 0x69, 0x74, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x69, 0x73, 0x20, 0x75, 0x6e, 0x6b, 0x6e, 0x6f,
    0x77, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72,
    0x2c, 0x20, 0x61, 0x20, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x4c, 0x4f, 0x53, 0x54, 0x20, 0x75, 0x70,
    0x64, 0x61, 0x74, 0x65, 0x20, 0x69, 0x73, 0x0a, 0x20, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74,
    0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x03, 0x03, 0x01, 0x12, 0x04, 0xfe,
    0x01, 0x0a, 0x0e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x01, 0x03, 0x03, 0x02, 0x00, 0x12, 0x04, 0xff,
    0x01, 0x04, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x03, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xff, 0x01, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x03, 0x02, 0x00, 0x06, 0x12,
    0x04, 0xff, 0x01, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x03, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xff, 0x01, 0x14, 0x1b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x03, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xff, 0x01, 0x1e, 0x1f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x01, 0x03, 0x03, 0x02,
    0x01, 0x12, 0x04, 0x80, 0x02, 0x04, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x03, 0x02,
    0x01, 0x04, 0x12, 0x04, 0x80, 0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x03,
    0x02, 0x01, 0x06, 0x12, 0x04, 0x80, 0x02, 0x0d, 0x14, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03,
    0x03, 0x02, 0x01, 0x01, 0x12, 0x04, 0x80, 0x02, 0x15, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01,
    0x03, 0x03, 0x02, 0x01, 0x03, 0x12, 0x04, 0x80, 0x02, 0x20, 0x21, 0x0a, 0xa8, 0x03, 0x0a, 0x04,
    0x04, 0x01, 0x03, 0x04, 0x12, 0x06, 0x8a, 0x02, 0x02, 0x8d, 0x02, 0x03, 0x1a, 0x97, 0x03, 0x20,
    0x53, 0x68, 0x75, 0x74, 0x73, 0x20, 0x64, 0x6f, 0x77, 0x6e, 0x20, 0x61, 0x20, 0x63, 0x75, 0x73,
    0x74, 0x6f, 0x6d, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x2e, 0x20, 0x57, 0x68,
    0x65, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20,
    0x67, 0x65, 0x74, 0x73, 0x20, 0x61, 0x20, 0x73, 0x68, 0x75, 0x74, 0x64, 0x6f, 0x77, 0x6e, 0x0a,
    0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x65, 0x78,
    0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x6b, 0x69, 0x6c, 0x6c, 0x20, 0x61,
    0x6c, 0x6c, 0x20, 0x69, 0x74, 0x73, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x28, 0x61, 0x6e,
    0x64, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x4b, 0x49, 0x4c, 0x4c,
    0x45, 0x44, 0x0a, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x73, 0x29, 0x20, 0x61, 0x6e, 0x64,
    0x20, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x65, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x64, 0x6f, 0x65, 0x73,
    0x6e, 0xe2, 0x80, 0x99, 0x74, 0x20, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x65, 0x20,
    0x77, 0x69, 0x74, 0x68, 0x69, 0x6e, 0x0a, 0x20, 0x61, 0x20, 0x63, 0x65, 0x72, 0x74, 0x61, 0x69,
    0x6e, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x20, 0x28, 0x63, 0x6f, 0x6e, 0x66, 0x69,
    0x67, 0x75, 0x72, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x76, 0x69, 0x61, 0x0a, 0x20, 0x27, 0x2d, 0x2d,
    0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x5f, 0x73, 0x68, 0x75, 0x74, 0x64, 0x6f, 0x77,
    0x6e, 0x5f, 0x67, 0x72, 0x61, 0x63, 0x65, 0x5f, 0x70, 0x65, 0x72, 0x69, 0x6f, 0x64, 0x27, 0x20,
    0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x66, 0x6c, 0x61, 0x67, 0x29, 0x2c, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x0a, 0x20, 0x66, 0x6f, 0x72,
    0x63, 0x65, 0x66, 0x75, 0x6c, 0x6c, 0x79, 0x20, 0x64, 0x65, 0x73, 0x74, 0x72, 0x6f, 0x79, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x28, 0x65,
    0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x69, 0x74, 0x73, 0x20,
    0x74, 0x61, 0x73, 0x6b, 0x73, 0x29, 0x20, 0x61, 0x6e, 0x64, 0x0a, 0x20, 0x74, 0x72, 0x61, 0x6e,
    0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x74, 0x73, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76,
    0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x54, 0x41, 0x53, 0x4b, 0x5f,
    0x4c, 0x4f, 0x53, 0x54, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x03, 0x04, 0x01, 0x12,
    0x04, 0x8a, 0x02, 0x0a, 0x12, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x01, 0x03, 0x04, 0x02, 0x00, 0x12,
    0x04, 0x8b, 0x02, 0x04, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x04, 0x02, 0x00, 0x04,
    0x12, 0x04, 0x8b, 0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x04, 0x02, 0x00,
    0x06, 0x12, 0x04, 0x8b, 0x02, 0x0d, 0x17, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x04, 0x02,
    0x00, 0x01, 0x12, 0x04, 0x8b, 0x02, 0x18, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x04,
    0x02, 0x00, 0x03, 0x12, 0x04, 0x8b, 0x02, 0x26, 0x27, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x01, 0x03,
    0x04, 0x02, 0x01, 0x12, 0x04, 0x8c, 0x02, 0x04, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03,
    0x04, 0x02, 0x01, 0x04, 0x12, 0x04, 0x8c, 0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01,
    0x03, 0x04, 0x02, 0x01, 0x06, 0x12, 0x04, 0x8c, 0x02, 0x0d, 0x14, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x01, 0x03, 0x04, 0x02, 0x01, 0x01, 0x12, 0x04, 0x8c, 0x02, 0x15, 0x1d, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x01, 0x03, 0x04, 0x02, 0x01, 0x03, 0x12, 0x04, 0x8c, 0x02, 0x20, 0x21, 0x0a, 0xa0, 0x02,
    0x0a, 0x04, 0x04, 0x01, 0x03, 0x05, 0x12, 0x06, 0x94, 0x02, 0x02, 0x98, 0x02, 0x03, 0x1a, 0x8f,
    0x02, 0x20, 0x41, 0x63, 0x6b, 0x6e, 0x6f, 0x77, 0x6c, 0x65, 0x64, 0x67, 0x65, 0x73, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x70, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x73, 0x74,
    0x61, 0x74, 0x75, 0x73, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x20, 0x53, 0x63, 0x68,
    0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x73, 0x20, 0x61, 0x72, 0x65, 0x0a, 0x20, 0x72, 0x65, 0x73,
    0x70, 0x6f, 0x6e, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x65, 0x78, 0x70,
    0x6c, 0x69, 0x63, 0x69, 0x74, 0x6c, 0x79, 0x20, 0x61, 0x63, 0x6b, 0x6e, 0x6f, 0x77, 0x6c, 0x65,
    0x64, 0x67, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x70,
    0x74, 0x20, 0x6f, 0x66, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x0a, 0x20, 0x75, 0x70, 0x64,
    0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x27,
    0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x28, 0x29, 0x2e,
    0x75, 0x75, 0x69, 0x64, 0x28, 0x29, 0x27, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x73, 0x65,
    0x74, 0x2e, 0x20, 0x53, 0x75, 0x63, 0x68, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x0a, 0x20,
    0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65, 0x74, 0x72,
    0x69, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74,
    0x20, 0x75, 0x6e, 0x74, 0x69, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 0x61, 0x72, 0x65, 0x20,
    0x61, 0x63, 0x6b, 0x6e, 0x6f, 0x77, 0x6c, 0x65, 0x64, 0x67, 0x65, 0x64, 0x20, 0x62, 0x79, 0x0a,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x03, 0x05, 0x01, 0x12, 0x04, 0x94, 0x02, 0x0a, 0x15, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x01, 0x03, 0x05, 0x02, 0x00, 0x12, 0x04, 0x95, 0x02, 0x04, 0x22, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x05, 0x02, 0x00, 0x04, 0x12, 0x04, 0x95, 0x02, 0x04, 0x0c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x05, 0x02, 0x00, 0x06, 0x12, 0x04, 0x95, 0x02, 0x0d,
    0x14, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x05, 0x02, 0x00, 0x01, 0x12, 0x04, 0x95, 0x02,
    0x15, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x05, 0x02, 0x00, 0x03, 0x12, 0x04, 0x95,
    0x02, 0x20, 0x21, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x01, 0x03, 0x05, 0x02, 0x01, 0x12, 0x04, 0x96,
    0x02, 0x04, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x05, 0x02, 0x01, 0x04, 0x12, 0x04,
    0x96, 0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x05, 0x02, 0x01, 0x06, 0x12,
    0x04, 0x96, 0x02, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x05, 0x02, 0x01, 0x01,
    0x12, 0x04, 0x96, 0x02, 0x14, 0x1b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x05, 0x02, 0x01,
    0x03, 0x12, 0x04, 0x96, 0x02, 0x1e, 0x1f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x01, 0x03, 0x05, 0x02,
    0x02, 0x12, 0x04, 0x97, 0x02, 0x04, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x05, 0x02,
    0x02, 0x04, 0x12, 0x04, 0x97, 0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x05,
    0x02, 0x02, 0x05, 0x12, 0x04, 0x97, 0x02, 0x0d, 0x12, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03,
    0x05, 0x02, 0x02, 0x01, 0x12, 0x04, 0x97, 0x02, 0x13, 0x17, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01,
    0x03, 0x05, 0x02, 0x02, 0x03, 0x12, 0x04, 0x97, 0x02, 0x1a, 0x1b, 0x0a, 0xdf, 0x02, 0x0a, 0x04,
    0x04, 0x01, 0x03, 0x06, 0x12, 0x06, 0xa0, 0x02, 0x02, 0xa8, 0x02, 0x03, 0x1a, 0xce, 0x02, 0x20,
    0x41, 0x6c, 0x6c, 0x6f, 0x77, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64,
    0x75, 0x6c, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x71, 0x75, 0x65, 0x72, 0x79, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x6e,
    0x2d, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x6c, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x2e,
    0x0a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x63, 0x61, 0x75, 0x73, 0x65, 0x73, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x65, 0x6e, 0x64,
    0x20, 0x62, 0x61, 0x63, 0x6b, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x61, 0x74, 0x65, 0x73, 0x74,
    0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x66, 0x6f, 0x72,
    0x0a, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x69, 0x6e, 0x20, 0x27,
    0x74, 0x61, 0x73, 0x6b, 0x73, 0x27, 0x2c, 0x20, 0x69, 0x66, 0x20, 0x70, 0x6f, 0x73, 0x73, 0x69,
    0x62, 0x6c, 0x65, 0x2e, 0x20, 0x54, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20,
    0x61, 0x72, 0x65, 0x20, 0x6e, 0x6f, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x65, 0x72, 0x20, 0x6b, 0x6e,
    0x6f, 0x77, 0x6e, 0x0a, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74,
    0x20, 0x69, 0x6e, 0x20, 0x61, 0x20, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x4c, 0x4f, 0x53, 0x54, 0x20,
    0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x27, 0x73, 0x74, 0x61, 0x74,
    0x75, 0x73, 0x65, 0x73, 0x27, 0x20, 0x69, 0x73, 0x20, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x2c, 0x20,
    0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72,
    0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c,
    0x61, 0x74, 0x65, 0x73, 0x74, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x66, 0x6f, 0x72,
    0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65,
    0x6e, 0x74, 0x6c, 0x79, 0x0a, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x01, 0x03, 0x06, 0x01, 0x12, 0x04, 0xa0, 0x02, 0x0a, 0x13, 0x0a, 0x54, 0x0a, 0x06,
    0x04, 0x01, 0x03, 0x06, 0x03, 0x00, 0x12, 0x06, 0xa2, 0x02, 0x04, 0xa5, 0x02, 0x05, 0x1a, 0x42,
    0x20, 0x54, 0x4f, 0x44, 0x4f, 0x28, 0x76, 0x69, 0x6e, 0x6f, 0x64, 0x29, 0x3a, 0x20, 0x53, 0x75,
    0x70, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x61, 0x72, 0x62, 0x69, 0x74, 0x72, 0x61, 0x72, 0x79, 0x20,
    0x71, 0x75, 0x65, 0x72, 0x69, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x20, 0x6a, 0x75, 0x73,
    0x74, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73,
    0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x06, 0x03, 0x00, 0x01, 0x12, 0x04, 0xa2,
    0x02, 0x0c, 0x10, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x01, 0x03, 0x06, 0x03, 0x00, 0x02, 0x00, 0x12,
    0x04, 0xa3, 0x02, 0x06, 0x22, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x01, 0x03, 0x06, 0x03, 0x00, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xa3, 0x02, 0x06, 0x0e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x01, 0x03, 0x06,
    0x03, 0x00, 0x02, 0x00, 0x06, 0x12, 0x04, 0xa3, 0x02, 0x0f, 0x15, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x01, 0x03, 0x06, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa3, 0x02, 0x16, 0x1d, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x01, 0x03, 0x06, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa3, 0x02, 0x20,
    0x21, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x01, 0x03, 0x06, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xa4,
    0x02, 0x06, 0x24, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x01, 0x03, 0x06, 0x03, 0x00, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xa4, 0x02, 0x06, 0x0e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x01, 0x03, 0x06, 0x03, 0x00,
    0x02, 0x01, 0x06, 0x12, 0x04, 0xa4, 0x02, 0x0f, 0x16, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x01, 0x03,
    0x06, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa4, 0x02, 0x17, 0x1f, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x01, 0x03, 0x06, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa4, 0x02, 0x22, 0x23, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x01, 0x03, 0x06, 0x02, 0x00, 0x12, 0x04, 0xa7, 0x02, 0x04, 0x1c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x06, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa7, 0x02, 0x04, 0x0c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x06, 0x02, 0x00, 0x06, 0x12, 0x04, 0xa7, 0x02, 0x0d,
    0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x06, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa7, 0x02,
    0x12, 0x17, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x06, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa7,
    0x02, 0x1a, 0x1b, 0x0a, 0xbb, 0x01, 0x0a, 0x04, 0x04, 0x01, 0x03, 0x07, 0x12, 0x06, 0xad, 0x02,
    0x02, 0xb1, 0x02, 0x03, 0x1a, 0xaa, 0x01, 0x20, 0x53, 0x65, 0x6e, 0x64, 0x73, 0x20, 0x61, 0x72,
    0x62, 0x69, 0x74, 0x72, 0x61, 0x72, 0x79, 0x20, 0x62, 0x69, 0x6e, 0x61, 0x72, 0x79, 0x20, 0x64,
    0x61, 0x74, 0x61, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75,
    0x74, 0x6f, 0x72, 0x2e, 0x20, 0x4e, 0x6f, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x4d,
    0x65, 0x73, 0x6f, 0x73, 0x0a, 0x20, 0x6e, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x69, 0x6e,
    0x74, 0x65, 0x72, 0x70, 0x72, 0x65, 0x74, 0x73, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x64, 0x61,
    0x74, 0x61, 0x20, 0x6e, 0x6f, 0x72, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x79,
    0x20, 0x67, 0x75, 0x61, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x65, 0x73, 0x20, 0x61, 0x62, 0x6f, 0x75,
    0x74, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x64, 0x65, 0x6c, 0x69, 0x76, 0x65, 0x72, 0x79, 0x20,
    0x6f, 0x66, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20,
    0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x03, 0x07, 0x01, 0x12, 0x04, 0xad, 0x02, 0x0a, 0x11,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x01, 0x03, 0x07, 0x02, 0x00, 0x12, 0x04, 0xae, 0x02, 0x04, 0x22,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x07, 0x02, 0x00, 0x04, 0x12, 0x04, 0xae, 0x02, 0x04,
    0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x07, 0x02, 0x00, 0x06, 0x12, 0x04, 0xae, 0x02,
    0x0d, 0x14, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x07, 0x02, 0x00, 0x01, 0x12, 0x04, 0xae,
    0x02, 0x15, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x07, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xae, 0x02, 0x20, 0x21, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x01, 0x03, 0x07, 0x02, 0x01, 0x12, 0x04,
    0xaf, 0x02, 0x04, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x07, 0x02, 0x01, 0x04, 0x12,
    0x04, 0xaf, 0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x07, 0x02, 0x01, 0x06,
    0x12, 0x04, 0xaf, 0x02, 0x0d, 0x17, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x07, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xaf, 0x02, 0x18, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x07, 0x02,
    0x01, 0x03, 0x12, 0x04, 0xaf, 0x02, 0x26, 0x27, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x01, 0x03, 0x07,
    0x02, 0x02, 0x12, 0x04, 0xb0, 0x02, 0x04, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x07,
    0x02, 0x02, 0x04, 0x12, 0x04, 0xb0, 0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03,
    0x07, 0x02, 0x02, 0x05, 0x12, 0x04, 0xb0, 0x02, 0x0d, 0x12, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01,
    0x03, 0x07, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb0, 0x02, 0x13, 0x17, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x01, 0x03, 0x07, 0x02, 0x02, 0x03, 0x12, 0x04, 0xb0, 0x02, 0x1a, 0x1b, 0x0a, 0xaf, 0x02, 0x0a,
    0x04, 0x04, 0x01, 0x03, 0x08, 0x12, 0x06, 0xb9, 0x02, 0x02, 0xbb, 0x02, 0x03, 0x1a, 0x9e, 0x02,
    0x20, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x20, 0x61, 0x20, 0x73, 0x70, 0x65, 0x63,
    0x69, 0x66, 0x69, 0x63, 0x20, 0x73, 0x65, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x72, 0x65, 0x73, 0x6f,
    0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73,
    0x27, 0x73, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x20, 0x49, 0x66,
    0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x20,
    0x68, 0x61, 0x73, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x74, 0x68, 0x69, 0x73, 0x2c, 0x20, 0x63, 0x6f, 0x72, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x64,
    0x69, 0x6e, 0x67, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x73, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20,
    0x62, 0x65, 0x0a, 0x20, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x61, 0x73, 0x79, 0x6e, 0x63, 0x68, 0x72,
    0x6f, 0x6e, 0x6f, 0x75, 0x73, 0x6c, 0x79, 0x20, 0x76, 0x69, 0x61, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x4f, 0x46, 0x46, 0x45, 0x52, 0x53, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x28, 0x73, 0x29, 0x2e,
    0x0a, 0x0a, 0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x54, 0x68, 0x65, 0x20, 0x62, 0x75, 0x69,
    0x6c, 0x74, 0x2d, 0x69, 0x6e, 0x20, 0x68, 0x69, 0x65, 0x72, 0x61, 0x72, 0x63, 0x68, 0x69, 0x63,
    0x61, 0x6c, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x20, 0x64, 0x6f, 0x65,
    0x73, 0x6e, 0x27, 0x74, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72,
    0x74, 0x0a, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x63, 0x61, 0x6c, 0x6c,
    0x20, 0x61, 0x6e, 0x64, 0x20, 0x68, 0x65, 0x6e, 0x63, 0x65, 0x20, 0x73, 0x69, 0x6d, 0x70, 0x6c,
    0x79, 0x20, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x73, 0x20, 0x69, 0x74, 0x2e, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x01, 0x03, 0x08, 0x01, 0x12, 0x04, 0xb9, 0x02, 0x0a, 0x11, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x01, 0x03, 0x08, 0x02, 0x00, 0x12, 0x04, 0xba, 0x02, 0x04, 0x2b, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x01, 0x03, 0x08, 0x02, 0x00, 0x04, 0x12, 0x04, 0xba, 0x02, 0x04, 0x0c, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x01, 0x03, 0x08, 0x02, 0x00, 0x06, 0x12, 0x04, 0xba, 0x02, 0x0d, 0x1d, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x08, 0x02, 0x00, 0x01, 0x12, 0x04, 0xba, 0x02, 0x1e, 0x26,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x08, 0x02, 0x00, 0x03, 0x12, 0x04, 0xba, 0x02, 0x29,
    0x2a, 0x0a, 0xea, 0x02, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x00, 0x12, 0x04, 0xc3, 0x02, 0x02, 0x28,
    0x1a, 0xdb, 0x02, 0x20, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x73, 0x20, 0x77,
    0x68, 0x6f, 0x20, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x20, 0x74, 0x68, 0x69,
    0x73, 0x20, 0x63, 0x61, 0x6c, 0x6c, 0x2e, 0x20, 0x4d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x61,
    0x73, 0x73, 0x69, 0x67, 0x6e, 0x73, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f,
    0x72, 0x6b, 0x20, 0x69, 0x64, 0x0a, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x61, 0x20, 0x6e, 0x65,
    0x77, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x73, 0x75, 0x62, 0x73,
    0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66,
    0x69, 0x72, 0x73, 0x74, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x20, 0x4f, 0x6e, 0x63, 0x65, 0x20,
    0x61, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x2c, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73,
    0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x73, 0x65,
    0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x27, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b,
    0x5f, 0x69, 0x64, 0x27, 0x20, 0x68, 0x65, 0x72, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x77, 0x69,
    0x74, 0x68, 0x69, 0x6e, 0x20, 0x69, 0x74, 0x73, 0x0a, 0x20, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77,
    0x6f, 0x72, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x20, 0x28, 0x69, 0x6e, 0x20, 0x61, 0x6e, 0x79, 0x20,
    0x66, 0x75, 0x72, 0x74, 0x68, 0x65, 0x72, 0x20, 0x27, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69,
    0x62, 0x65, 0x27, 0x20, 0x63, 0x61, 0x6c, 0x6c, 0x73, 0x29, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73,
    0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x73, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x6d, 0x61, 0x73,
    0x74, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x79, 0x20,
    0x61, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x63, 0x6f, 0x72, 0x72,
    0x65, 0x63, 0x74, 0x6c, 0x79, 0x20, 0x61, 0x63, 0x72, 0x6f, 0x73, 0x73, 0x20, 0x64, 0x69, 0x73,
    0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2c, 0x0a, 0x20, 0x66, 0x61,
    0x69, 0x6c, 0x6f, 0x76, 0x65, 0x72, 0x73, 0x2c, 0x20, 0x65, 0x74, 0x63, 0x2e, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc3, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x01, 0x02, 0x00, 0x06, 0x12, 0x04, 0xc3, 0x02, 0x0b, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc3, 0x02, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc3, 0x02, 0x26, 0x27, 0x0a, 0x87, 0x01, 0x0a, 0x04, 0x04,
    0x01, 0x02, 0x01, 0x12, 0x04, 0xc7, 0x02, 0x02, 0x19, 0x1a, 0x79, 0x20, 0x54, 0x79, 0x70, 0x65,
    0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x61, 0x6c, 0x6c, 0x2c, 0x20, 0x69, 0x6e,
    0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x73, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x6f, 0x70,
    0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x6c,
    0x6f, 0x77, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x0a, 0x20, 0x70, 0x72,
    0x65, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x79,
    0x70, 0x65, 0x20, 0x68, 0x61, 0x73, 0x20, 0x61, 0x20, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20,
    0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69,
    0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc7,
    0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x06, 0x12, 0x04, 0xc7, 0x02,
    0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc7, 0x02, 0x10,
    0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc7, 0x02, 0x17, 0x18,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x02, 0x12, 0x04, 0xc9, 0x02, 0x02, 0x23, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x01, 0x02, 0x02, 0x04, 0x12, 0x04, 0xc9, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x01, 0x02, 0x02, 0x06, 0x12, 0x04, 0xc9, 0x02, 0x0b, 0x14, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x01, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc9, 0x02, 0x15, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x01, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc9, 0x02, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x01,
    0x02, 0x03, 0x12, 0x04, 0xca, 0x02, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x03,
    0x04, 0x12, 0x04, 0xca, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x03, 0x06,
    0x12, 0x04, 0xca, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xca, 0x02, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xca, 0x02, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x04, 0x12, 0x04, 0xcb, 0x02,
    0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x04, 0x04, 0x12, 0x04, 0xcb, 0x02, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x04, 0x06, 0x12, 0x04, 0xcb, 0x02, 0x0b, 0x12,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x04, 0x01, 0x12, 0x04, 0xcb, 0x02, 0x13, 0x1a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x04, 0x03, 0x12, 0x04, 0xcb, 0x02, 0x1d, 0x1e, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x01, 0x02, 0x05, 0x12, 0x04, 0xcc, 0x02, 0x02, 0x19, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x01, 0x02, 0x05, 0x04, 0x12, 0x04, 0xcc, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x01, 0x02, 0x05, 0x06, 0x12, 0x04, 0xcc, 0x02, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01,
    0x02, 0x05, 0x01, 0x12, 0x04, 0xcc, 0x02, 0x10, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02,
    0x05, 0x03, 0x12, 0x04, 0xcc, 0x02, 0x17, 0x18, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x06,
    0x12, 0x04, 0xcd, 0x02, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x06, 0x04, 0x12,
    0x04, 0xcd, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x06, 0x06, 0x12, 0x04,
    0xcd, 0x02, 0x0b, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x06, 0x01, 0x12, 0x04, 0xcd,
    0x02, 0x14, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x06, 0x03, 0x12, 0x04, 0xcd, 0x02,
    0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x07, 0x12, 0x04, 0xce, 0x02, 0x02, 0x27,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x07, 0x04, 0x12, 0x04, 0xce, 0x02, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x07, 0x06, 0x12, 0x04, 0xce, 0x02, 0x0b, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x01, 0x02, 0x07, 0x01, 0x12, 0x04, 0xce, 0x02, 0x17, 0x22, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x01, 0x02, 0x07, 0x03, 0x12, 0x04, 0xce, 0x02, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x01, 0x02, 0x08, 0x12, 0x04, 0xcf, 0x02, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01,
    0x02, 0x08, 0x04, 0x12, 0x04, 0xcf, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02,
    0x08, 0x06, 0x12, 0x04, 0xcf, 0x02, 0x0b, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x08,
    0x01, 0x12, 0x04, 0xcf, 0x02, 0x15, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x08, 0x03,
    0x12, 0x04, 0xcf, 0x02, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x09, 0x12, 0x04,
    0xd0, 0x02, 0x02, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x09, 0x04, 0x12, 0x04, 0xd0,
    0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x09, 0x06, 0x12, 0x04, 0xd0, 0x02,
    0x0b, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x09, 0x01, 0x12, 0x04, 0xd0, 0x02, 0x13,
    0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x09, 0x03, 0x12, 0x04, 0xd0, 0x02, 0x1d, 0x1f,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x0a, 0x12, 0x04, 0xd1, 0x02, 0x02, 0x20, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x01, 0x02, 0x0a, 0x04, 0x12, 0x04, 0xd1, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x01, 0x02, 0x0a, 0x06, 0x12, 0x04, 0xd1, 0x02, 0x0b, 0x12, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x01, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xd1, 0x02, 0x13, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x01, 0x02, 0x0a, 0x03, 0x12, 0x04, 0xd1, 0x02, 0x1d, 0x1f,
];

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
